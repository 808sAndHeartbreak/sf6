<!DOCTYPE html>
<html lang="zh-CN" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>SF6 FRAME LAB - 街霸6 帧数计算器</title>
    <meta name="description" content="Street Fighter 6 帧数压制计算工具，自动计算最优卡帧方案和投技时机">
    <meta name="keywords" content="SF6, Street Fighter 6, 街霸6, 帧数, Frame Data, 压起身, Meaty, Okizeme">
    <!-- Open Graph 社交分享 -->
    <meta property="og:title" content="SF6 FRAME LAB - 帧数计算器">
    <meta property="og:description" content="Street Fighter 6 压起身帧数计算工具">
    <meta property="og:type" content="website">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&display=swap" rel="stylesheet">
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* 使用系统字体，无需外部加载 */
        :root {
            --theme-primary: #ff007a;
            --theme-secondary: #00f2ff;
            --theme-accent: #ffd700;
            --theme-bg: #0a0a0c;
            --theme-card-bg: #111114;
            --theme-card-border: #222;
        }

        html {
            scrollbar-gutter: stable;
        }

        body { 
            background-color: var(--theme-bg); 
            color: #fff; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft YaHei", "PingFang SC", sans-serif;
            position: relative;
        }
        
        /* SF6 页面 body 顶部间距（header 52px） */
        .sf6-body {
            padding-top: 52px !important;
        }
        
        @media (max-width: 768px) {
            .sf6-body {
                padding-top: 48px !important;
            }
        }
        
        .impact-text { 
            font-family: "Arial Black", "Helvetica Neue", Impact, sans-serif; 
            text-transform: uppercase; 
            font-style: italic; 
        }
        
        /* ========== 阶段A：Glitch 动态效果 ========== */
        /* 主标题 - 常驻发光 + 呼吸效果 */
        .glitch-hover {
            position: relative;
            cursor: default;
            user-select: none;
            display: inline-block;
            /* 常驻柔和发光 */
            text-shadow: 
                0 0 10px var(--theme-primary),
                0 0 20px color-mix(in srgb, var(--theme-primary) 60%, transparent),
                0 0 30px color-mix(in srgb, var(--theme-primary) 30%, transparent);
            animation: glow-breathe 3s ease-in-out infinite;
        }
        
        /* 呼吸发光动画 */
        @keyframes glow-breathe {
            0%, 100% {
                text-shadow: 
                    0 0 8px var(--theme-primary),
                    0 0 16px color-mix(in srgb, var(--theme-primary) 50%, transparent),
                    0 0 24px color-mix(in srgb, var(--theme-primary) 25%, transparent);
            }
            50% {
                text-shadow: 
                    0 0 12px var(--theme-primary),
                    0 0 25px color-mix(in srgb, var(--theme-primary) 70%, transparent),
                    0 0 40px color-mix(in srgb, var(--theme-primary) 40%, transparent);
            }
        }
        
        /* 悬停/切换时：抖动 + 强化发光 */
        html.loaded .glitch-hover:hover,
        html.loaded .glitch-hover.glitch-active {
            animation: glitch-chaotic 1s steps(1) infinite !important;
            text-shadow: 
                4px 0 var(--theme-primary), 
                -4px 0 var(--theme-secondary),
                0 0 30px var(--theme-primary),
                0 0 60px var(--theme-primary),
                0 0 100px color-mix(in srgb, var(--theme-primary) 70%, transparent),
                0 0 150px color-mix(in srgb, var(--theme-primary) 40%, transparent) !important;
        }
        
        /* 悬停离开后立即静止，恢复常驻发光 */
        html.loaded .glitch-hover:not(:hover):not(.glitch-active) {
            animation: none !important;
            transform: none;
            /* 保留常驻发光，通过继承 .glitch-hover 的 text-shadow */
        }
        
        @keyframes glitch-chaotic {
            /* 0-80%: 快速抖动闪烁（约0.8秒） */
            0% { transform: translate(0) skewX(0); }
            5% { transform: translate(-4px, 3px) skewX(-3deg); }
            7% { transform: translate(0) skewX(0); }
            13% { transform: translate(3px, -2px) skewX(2deg); }
            15% { transform: translate(0) skewX(0); }
            21% { transform: translate(-2px, -3px) skewX(-1deg); }
            23% { transform: translate(0) skewX(0); }
            29% { transform: translate(5px, 1px) skewX(4deg); }
            31% { transform: translate(0) skewX(0); }
            37% { transform: translate(-3px, 2px) skewX(-2deg); }
            39% { transform: translate(0) skewX(0); }
            45% { transform: translate(2px, -4px) skewX(3deg); }
            47% { transform: translate(0) skewX(0); }
            53% { transform: translate(-1px, 1px) skewX(-1deg); }
            55% { transform: translate(0) skewX(0); }
            61% { transform: translate(4px, -1px) skewX(2deg); }
            63% { transform: translate(0) skewX(0); }
            69% { transform: translate(-3px, -2px) skewX(-2deg); }
            71% { transform: translate(0) skewX(0); }
            77% { transform: translate(2px, 3px) skewX(1deg); }
            80% { transform: translate(0) skewX(0); }
            /* 80-100%: 慢速弱抖动收尾（约0.2秒） */
            87% { transform: translate(0.8px, -0.4px) skewX(0.4deg); }
            94% { transform: translate(-0.4px, 0.3px) skewX(-0.2deg); }
            100% { transform: translate(0) skewX(0); }
        }
        
        /* 招式名悬停 - 优雅微动效 + 发光 */
        .glitch-text {
            cursor: default;
            display: inline-block;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            font-size: 0.93em; /* 整体稍小，视觉平衡中文 */
        }
        
        .glitch-text:hover {
            transform: translateY(-2px);
            text-shadow: 0 0 15px var(--theme-primary), 0 4px 12px rgba(0, 0, 0, 0.5);
            filter: brightness(1.15);
        }
        
        /* 帧数数字悬停效果 */
        .frame-number {
            cursor: default;
            display: inline-block;
        }
        
        .frame-number:hover {
            animation: glitch-number 0.2s ease;
            color: var(--theme-primary);
            text-shadow: 0 0 20px var(--theme-primary), 0 0 40px var(--theme-primary);
        }
        
        @keyframes glitch-number {
            0%, 100% { transform: translate(0); opacity: 1; }
            33% { transform: translate(2px, -1px); opacity: 0.8; }
            66% { transform: translate(-2px, 1px); opacity: 0.9; }
        }
        
        /* ========== 收藏卡片视图 ========== */
        .fav-card {
            background: color-mix(in srgb, var(--theme-primary) 15%, #111);
            border: 3px solid var(--theme-primary);
            padding: 1.25rem 1.5rem;
            position: relative;
            transition: all 0.2s ease;
        }
        
        .fav-card:hover {
            border-color: var(--theme-secondary);
            background: color-mix(in srgb, var(--theme-primary) 25%, #111);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }
        
        .fav-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .fav-card-adv {
            font-family: 'Arial Black', Impact, sans-serif;
            font-size: 1rem;
            font-weight: 900;
            color: var(--theme-secondary);
        }
        
        .fav-card-star {
            font-size: 1.125rem;
            color: #facc15;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0.25rem;
            opacity: 0.7;
        }
        
        .fav-card-star:hover {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .fav-card-plan {
            background: #000;
            color: #fff;
            font-size: 1.75rem;
            font-weight: 900;
            padding: 0.875rem 1rem;
            margin-bottom: 0.75rem;
            text-align: center;
            border: 2px solid var(--theme-primary);
        }
        
        .fav-card-plan-arrow {
            color: var(--theme-secondary);
            margin: 0 0.5rem;
        }
        
        .fav-card-contexts {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .fav-card-context {
            background: var(--theme-primary);
            color: #000;
            font-size: 1rem;
            font-weight: 900;
            padding: 0.5rem 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }
        
        .fav-card-mixup-tag {
            display: inline-block;
            background: color-mix(in srgb, var(--theme-secondary) 30%, transparent);
            border: 2px solid var(--theme-secondary);
            color: var(--theme-secondary);
            font-size: 0.875rem;
            font-weight: 900;
            padding: 0.375rem 0.75rem;
            margin-top: 0.75rem;
        }
        
        /* 卡片移除动画 */
        .fav-card.removing {
            animation: fav-card-remove 0.3s ease forwards;
        }
        
        @keyframes fav-card-remove {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.8); }
        }
        
        /* ========== 第一阶段：New-Brutalism 结构强化 ========== */
        .trend-card { 
            background: color-mix(in srgb, var(--theme-primary) 10%, #0a0a0c);
            border: 3px solid color-mix(in srgb, var(--theme-primary) 40%, #333);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .trend-card:hover { 
            border-color: var(--theme-primary); 
            background: color-mix(in srgb, var(--theme-primary) 15%, #0a0a0c);
            /* New-Brutalism 半硬阴影：有位移 + 轻微模糊 */
            box-shadow: 6px 6px 0 color-mix(in srgb, var(--theme-primary) 60%, transparent);
            transform: translate(-2px, -2px);
        }
        
        .trend-card:active {
            transform: translate(0, 0);
            box-shadow: 2px 2px 0 color-mix(in srgb, var(--theme-primary) 40%, transparent);
        }

        .btn-hype {
            background: var(--theme-secondary);
            color: #000;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 900;
        }

        .btn-hype:hover {
            background: var(--theme-primary);
            color: #fff;
            box-shadow: 0 0 25px var(--theme-primary), 0 0 50px color-mix(in srgb, var(--theme-primary) 50%, transparent);
        }
        
        /* 次要按钮 - 暗色主题色 */
        .btn-secondary {
            background: color-mix(in srgb, var(--theme-primary) 70%, #000);
            color: #fff;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 900;
        }
        
        .btn-secondary:hover {
            background: var(--theme-primary);
            box-shadow: 0 0 15px color-mix(in srgb, var(--theme-primary) 50%, transparent);
        }
        
        .btn-secondary:active {
            transform: translateY(2px);
            filter: brightness(0.9);
        }
        
        /* ========== 第三阶段：物理点击反馈 ========== */
        .btn-hype:active {
            transform: translateY(3px);
            box-shadow: none;
            filter: brightness(0.85);
        }

        /* ========== 推荐理由提示框 ========== */
        .recommend-card {
            position: relative;
        }
        
        .recommend-tooltip {
            position: absolute;
            top: 50%;
            left: -10px;
            transform: translate(-100%, -50%);
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.95) 0%, rgba(59, 130, 246, 0.95) 100%);
            color: #000;
            font-size: 11px;
            font-weight: 700;
            line-height: 1.6;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s, transform 0.25s;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
        }
        
        .recommend-tooltip::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 6px 0 6px 6px;
            border-color: transparent transparent transparent rgba(59, 130, 246, 0.95);
        }
        
        .recommend-card:hover .recommend-tooltip {
            opacity: 1;
            transform: translate(-100%, -50%) translateX(-8px);
        }
        
        /* 移动端优化：提示框显示在上方 */
        @media (max-width: 1024px) {
            .recommend-tooltip {
                top: -10px;
                left: 50%;
                transform: translate(-50%, -100%);
            }
            
            .recommend-tooltip::after {
                top: 100%;
                right: auto;
                left: 50%;
                transform: translateX(-50%);
                border-width: 6px 6px 0 6px;
                border-color: rgba(59, 130, 246, 0.95) transparent transparent transparent;
            }
            
            .recommend-card:hover .recommend-tooltip {
                transform: translate(-50%, -100%) translateY(-8px);
            }
        }
        
        /* ========== 第五阶段：收藏印章标签 ========== */
        .favorite-stamp {
            position: absolute;
            top: -4px;
            left: -4px;
            background: #f59e0b;
            color: #000;
            font-size: 9px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 3px 10px;
            transform: rotate(-8deg);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.3);
            z-index: 5;
            pointer-events: none;
        }

        /* Tab 矩形开关按钮组 */
        .tab-btn {
            font-family: "Arial Black", "Helvetica Neue", Impact, sans-serif;
            font-style: italic;
            font-size: 0.9rem;
            color: #555;
            background: transparent;
            border: none;
            padding: 0.55rem 1rem;
            transition: color 0.25s, transform 0.15s;
            position: relative;
        }
        
        /* 下划线展开效果 */
        .tab-btn::after {
            content: '';
            position: absolute;
            bottom: 6px;
            left: 50%;
            width: 0;
            height: 2px;
            background: var(--theme-secondary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateX(-50%);
        }
        
        .tab-btn:hover:not(.active)::after {
            width: 70%;
        }
        
        /* 规则类型 Tab 按钮 */
        .rule-tab-btn {
            color: #71717a;
            border-bottom: 2px solid transparent;
            transition: all 0.25s;
        }
        
        .rule-tab-btn:hover {
            color: #a1a1aa;
        }
        
        .rule-tab-btn.active {
            color: var(--theme-secondary);
            border-bottom-color: var(--theme-secondary);
        }
        
        /* 打投择 Tab 按钮 */
        .mixup-tab-btn {
            color: #71717a;
            border-bottom: 2px solid transparent;
            transition: all 0.25s;
            background: transparent;
        }
        
        .mixup-tab-btn:hover {
            color: #a1a1aa;
        }
        
        .mixup-tab-btn.active {
            color: var(--theme-primary);
            border-bottom-color: var(--theme-primary);
        }
        
        /* 打投择方案箭头旋转 */
        #mixupDetails[open] .mixup-arrow {
            transform: rotate(90deg);
        }
        
        /* 期望后续箭头旋转 */
        #expectDetails[open] .expect-arrow {
            transform: rotate(90deg);
        }
        
        /* 通用折叠箭头旋转 */
        details[open] .collapse-arrow {
            transform: rotate(90deg);
        }
        
        .tab-btn:hover:not(.active) {
            color: #aaa;
        }
        
        .tab-btn:active {
            transform: scale(0.96);
        }

        .tab-btn.active { 
            color: #000;
            font-weight: 900;
        }
        
        .tab-btn.active::after {
            width: 0;
        }

        /* JSON 提示区 */
        .json-hint {
            background: color-mix(in srgb, var(--theme-secondary) 5%, transparent);
            border: 1px dashed var(--theme-secondary);
            padding: 8px;
            font-size: 11px;
            color: var(--theme-secondary);
        }

        /* 角色选择按钮 - Opium/Trap 菱形风格 */
        .champion-btn {
            font-family: "Arial Black", "Helvetica Neue", Impact, sans-serif;
            font-weight: 900;
            font-size: 1.5rem;
            letter-spacing: 0.1em;
            color: #fff;
            transition: all 0.3s;
            background: color-mix(in srgb, var(--theme-primary) 20%, #000);
            border: 2px solid var(--theme-primary);
            padding: 0.5rem 1.4rem;
            position: relative;
            cursor: pointer;
            /* 菱形斜切 */
            clip-path: polygon(10px 0, 100% 0, calc(100% - 10px) 100%, 0 100%);
            margin-right: auto;
        }
        
        /* 内发光边框效果 */
        .champion-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(0,0,0,0.2) 100%);
            pointer-events: none;
        }
        
        .champion-btn:hover {
            background: color-mix(in srgb, var(--theme-primary) 40%, #000);
            border-color: var(--theme-primary);
            box-shadow: 
                0 0 20px color-mix(in srgb, var(--theme-primary) 50%, transparent),
                inset 0 0 15px color-mix(in srgb, var(--theme-primary) 30%, transparent);
            color: #fff;
            text-shadow: 0 0 10px var(--theme-primary);
        }
        
        .champion-btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }
        
        .champion-btn .char-icon {
            font-size: 1.6rem;
            transition: transform 0.3s;
        }
        
        .champion-btn .char-text {
            font-family: "Arial Black", Impact, "Noto Sans SC", "Microsoft YaHei", sans-serif;
            font-weight: 900;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
        }
        
        .champion-btn:hover .char-icon {
            transform: scale(1.15);
        }
        
        /* 角色按钮切换动画 */
        @keyframes char-btn-pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 rgba(var(--theme-primary-rgb, 255, 0, 122), 0);
            }
            15% {
                transform: scale(1.05) translateX(-2px);
                box-shadow: 
                    0 0 20px var(--theme-primary),
                    inset 0 0 10px color-mix(in srgb, var(--theme-primary) 30%, transparent);
            }
            30% {
                transform: scale(1.02) translateX(2px);
            }
            45% {
                transform: scale(1.04) translateX(-1px);
                box-shadow: 
                    0 0 30px var(--theme-primary),
                    0 0 60px color-mix(in srgb, var(--theme-primary) 50%, transparent),
                    inset 0 0 15px color-mix(in srgb, var(--theme-primary) 40%, transparent);
            }
            60% {
                transform: scale(1.01) translateX(1px);
            }
            75% {
                transform: scale(1.03);
                box-shadow: 
                    0 0 15px var(--theme-primary),
                    inset 0 0 8px color-mix(in srgb, var(--theme-primary) 20%, transparent);
            }
            100% {
                transform: scale(1);
                box-shadow: none;
            }
        }
        
        .champion-btn.char-switch-active {
            animation: char-btn-pulse 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            border-color: var(--theme-secondary) !important;
        }
        
        .champion-btn.char-switch-active .char-icon {
            animation: char-icon-bounce 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
        }
        
        @keyframes char-icon-bounce {
            0%, 100% { transform: scale(1) rotate(0deg); }
            20% { transform: scale(1.3) rotate(-10deg); }
            40% { transform: scale(1.1) rotate(5deg); }
            60% { transform: scale(1.2) rotate(-5deg); }
            80% { transform: scale(1.05) rotate(2deg); }
        }

        /* 角色选择网格 - 响应式 */
        .char-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
            padding-bottom: 8px; /* 为hover放大效果预留空间，避免出现滚动条 */
        }
        
        /* 超小屏幕优化：3列更易点击 */
        @media (max-width: 359px) {
            .char-grid { 
                grid-template-columns: repeat(3, 1fr); 
                gap: 6px;
            }
        }
        
        @media (min-width: 640px) {
            .char-grid { 
                grid-template-columns: repeat(5, 1fr); 
                gap: 8px;
            }
        }
        
        @media (min-width: 768px) {
            .char-grid { 
                grid-template-columns: repeat(6, 1fr); 
                gap: 10px;
            }
        }

        .char-item {
            aspect-ratio: 1.1;
            background: #1a1a2e;
            border: 2px solid #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 4px;
        }
        
        .char-item:hover {
            border-color: var(--theme-secondary);
            transform: scale(1.05);
        }
        
        .char-item.selected {
            border-color: var(--theme-primary);
            background: var(--theme-card-bg);
            box-shadow: 0 0 15px color-mix(in srgb, var(--theme-primary) 30%, transparent);
        }
        
        .char-item.no-data { 
            opacity: 0.3; 
            cursor: not-allowed;
            filter: grayscale(0.8);
        }
        .char-item.no-data:hover { 
            opacity: 0.35; 
            transform: none;
            border-color: #333;
        }
        
        .char-name {
            font-family: "Arial Black", "Helvetica Neue", Impact, sans-serif;
            font-size: 9px;
            font-weight: 900;
            text-transform: uppercase;
            margin-top: 2px;
            line-height: 1.1;
            text-align: center;
        }
        
        .char-icon { font-size: 20px; }
        
        /* 较大屏幕恢复尺寸 */
        @media (min-width: 480px) {
            .char-item {
                aspect-ratio: 1.2;
                padding: 6px;
            }
            .char-name {
                font-size: 11px;
                margin-top: 4px;
            }
            .char-icon { font-size: 24px; }
        }
        
        /* ========== 移动端优化 ========== */
        /* 触摸设备上移除 hover 变换效果，避免 sticky hover */
        @media (hover: none) {
            .char-item:hover { transform: none; }
            .trend-card:hover { 
                border-color: color-mix(in srgb, var(--theme-primary) 40%, #333); 
                background: color-mix(in srgb, var(--theme-primary) 10%, #0a0a0c);
                box-shadow: none;
                transform: none;
            }
        }
        
        /* 移动端始终显示操作按钮（不依赖 hover） */
        @media (hover: none), (max-width: 640px) {
            .group .group-hover\:opacity-100 {
                opacity: 1 !important;
            }
            .sm\:opacity-0 {
                opacity: 0.7 !important;
            }
            .sm\:group-hover\/ctx\:opacity-100 {
                opacity: 1 !important;
            }
            /* 打投择卡片操作按钮 - 增大点击区域 */
            .group button[onclick*="copyPlanInfo"],
            .group button[onclick*="openMixupEditModal"],
            .group button[onclick*="toggleMixupFavorite"] {
                min-width: 36px;
                min-height: 36px;
                padding: 8px;
                font-size: 14px;
            }
        }
        
        /* 防止 iOS 输入框缩放 */
        input, textarea, select {
            font-size: 16px;
        }
        @media (min-width: 640px) {
            input, textarea, select {
                font-size: inherit;
            }
        }
        
        /* 优化滚动性能 */
        .overflow-x-auto, .overflow-y-auto {
            -webkit-overflow-scrolling: touch;
        }
        
        /* 防止长按弹出菜单 */
        button, a {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* ========== 可访问性优化 ========== */
        /* 统一焦点样式 */
        button:focus-visible, 
        input:focus-visible, 
        textarea:focus-visible,
        select:focus-visible,
        a:focus-visible,
        details summary:focus-visible {
            outline: 2px solid var(--theme-secondary);
            outline-offset: 2px;
        }
        
        /* 减少动画（用户偏好） */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* 高对比度模式支持 */
        @media (prefers-contrast: high) {
            .trend-card {
                border-width: 3px;
            }
            button {
                border: 2px solid currentColor;
            }
        }
        
        /* 按钮点击反馈 */
        button:active:not(:disabled) {
            transform: scale(0.97);
        }
        
        /* 主题色 Modal 按钮 */
        .modal-btn-primary {
            background-color: var(--theme-btn-primary);
        }
        .modal-btn-primary:hover {
            background-color: var(--theme-btn-primary-hover);
        }
        .modal-btn-active {
            background-color: var(--theme-btn-primary);
        }
        
        /* 排序按钮样式 */
        .sort-btn {
            background: #18181b;
            border-color: color-mix(in srgb, var(--theme-secondary) 60%, #333);
            color: var(--theme-secondary);
        }
        .sort-btn:hover {
            background: color-mix(in srgb, var(--theme-primary) 20%, #18181b);
            border-color: var(--theme-primary);
            color: var(--theme-primary);
        }
        
        /* Context 标签样式 */
        .context-tag {
            color: var(--theme-primary);
            background: color-mix(in srgb, var(--theme-secondary) 15%, transparent);
            border-color: var(--theme-secondary);
        }
        
        /* 预设场景标签样式 - 提高可见度 */
        .context-tag-preset {
            color: #d0d0d0;
            background: color-mix(in srgb, var(--theme-secondary) 12%, transparent);
            border-color: #606070;
        }
        
        /* 展开状态的场景标签 */
        .expanded-context-tag {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        @media (max-width: 640px) {
            .expanded-context-tag {
                max-width: 150px;
            }
        }
        
        /* 折叠状态的场景标签 - 高可见度 */
        .compact-context-tag {
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            background: color-mix(in srgb, var(--theme-primary) 25%, transparent);
            border: 1px solid color-mix(in srgb, var(--theme-primary) 50%, transparent);
            color: var(--theme-secondary);
            text-transform: uppercase;
            letter-spacing: 0.02em;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        /* 移动端场景标签优化 */
        @media (max-width: 480px) {
            .compact-context-tag {
                font-size: 10px;
                padding: 2px 6px;
                max-width: 80px;
            }
        }
        
        /* 折叠状态方案描述 - 移动端截断 */
        .compact-plan-desc {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        @media (max-width: 640px) {
            .compact-plan-desc {
                max-width: 150px;
            }
        }
        
        @media (max-width: 400px) {
            .compact-plan-desc {
                max-width: 100px;
            }
        }
        
        /* 安全跳标签 - 斜切菱形风格 */
        .safe-jump-badge {
            display: inline-block;
        }
        .safe-jump-badge-inner {
            display: inline-block;
            font-size: 11px;
            font-weight: 900;
            padding: 4px 12px 4px 10px;
            letter-spacing: 0.5px;
            position: relative;
            clip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .safe-jump-true {
            background: linear-gradient(135deg, #16a34a 0%, #22c55e 50%, #16a34a 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
        }
        .safe-jump-pseudo {
            background: linear-gradient(135deg, #ca8a04 0%, #eab308 50%, #ca8a04 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(234, 179, 8, 0.4);
        }
        .safe-jump-badge-inner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.2) 0%, transparent 50%);
            clip-path: inherit;
            pointer-events: none;
        }
        
        /* 帧数输入组件 */
        .adv-input-group {
            display: flex;
            border: 1px solid var(--theme-card-border);
        }
        .adv-input-group .adv-btn {
            width: 56px;
            background: #27272a;
            color: #a1a1aa;
            font-size: 1.5rem;
            font-weight: bold;
            transition: all 0.15s;
            user-select: none;
            border: none;
        }
        .adv-input-group .adv-btn:hover {
            background: #3f3f46;
            color: white;
        }
        .adv-input-group .adv-btn:first-child {
            border-right: 1px solid var(--theme-card-border);
        }
        .adv-input-group .adv-btn:last-child {
            border-left: 1px solid var(--theme-card-border);
        }
        .adv-input-group .adv-input {
            flex: 1;
            min-width: 0;
            background: black;
            padding: 1rem;
            font-size: 2.25rem;
            font-weight: 900;
            text-align: center;
            color: var(--theme-input-accent);
            border: none;
            outline: none;
        }
        .adv-input-group .adv-input::placeholder {
            color: #52525b;
        }
        
        /* 模糊帧数滑动开关 */
        .fuzzy-switch-container {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }
        .fuzzy-switch-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            transition: all 0.2s;
        }
        .fuzzy-switch-label-inactive {
            color: #52525b;
        }
        .fuzzy-switch {
            width: 36px;
            height: 20px;
            background: #27272a;
            border: 1px solid var(--theme-card-border);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s ease;
        }
        .fuzzy-switch-thumb {
            width: 14px;
            height: 14px;
            background: var(--theme-secondary, #ff1493);
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .fuzzy-switch.active {
            background: var(--theme-fuzzy, #f59e0b);
            border-color: var(--theme-fuzzy, #f59e0b);
        }
        .fuzzy-switch.active .fuzzy-switch-thumb {
            left: 18px;
            background: white;
        }
        
        /* 模糊帧数范围输入 */
        .fuzzy-input-group {
            display: flex;
            align-items: center;
            border: 1px solid var(--theme-card-border);
            background: black;
        }
        .fuzzy-input-group .fuzzy-input {
            flex: 1;
            min-width: 0;
            background: transparent;
            padding: 1rem;
            font-size: 2rem;
            font-weight: 900;
            text-align: center;
            color: var(--theme-input-accent);
            border: none;
            outline: none;
        }
        .fuzzy-input-group .fuzzy-input::placeholder {
            color: #52525b;
        }
        .fuzzy-input-group .fuzzy-separator {
            color: #71717a;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 0 0.5rem;
        }
        
        /* 模糊帧数预览结果 */
        .fuzzy-preview {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--theme-card-border);
        }
        .fuzzy-preview-title {
            font-size: 0.75rem;
            font-weight: bold;
            text-transform: uppercase;
            color: #71717a;
            margin-bottom: 0.75rem;
        }
        .fuzzy-preview-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #18181b;
            border-left: 3px solid var(--theme-btn-primary);
        }
        .fuzzy-preview-item:last-child {
            margin-bottom: 0;
        }
        .fuzzy-preview-label {
            font-size: 0.625rem;
            font-weight: bold;
            text-transform: uppercase;
            color: #71717a;
            margin-bottom: 0.25rem;
        }
        .fuzzy-preview-plan {
            font-weight: bold;
            color: white;
        }
        .fuzzy-preview-avg {
            font-size: 0.75rem;
            color: #a1a1aa;
            margin-top: 0.25rem;
        }
        .fuzzy-preview-detail {
            font-size: 0.625rem;
            color: #71717a;
            margin-top: 0.25rem;
        }
        
        /* 模糊场景卡片 */
        .fuzzy-scenario-card {
            border-left: 3px solid var(--theme-fuzzy, #f59e0b);
        }
        .fuzzy-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: rgba(245, 158, 11, 0.15);
            border: 1px solid rgba(245, 158, 11, 0.3);
            color: #f59e0b;
            font-size: 0.625rem;
            font-weight: bold;
        }
        .fuzzy-plan-card {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--theme-card-border);
            padding: 0.75rem 1rem;
        }
        .fuzzy-plan-label {
            font-size: 0.625rem;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--theme-fuzzy, #f59e0b);
            margin-bottom: 0.25rem;
        }
        .fuzzy-plan-desc {
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        .fuzzy-plan-stats {
            font-size: 0.75rem;
            color: #a1a1aa;
            display: flex;
            gap: 1rem;
        }
        .fuzzy-plan-detail {
            font-size: 0.625rem;
            color: #71717a;
            margin-top: 0.25rem;
        }
        
        /* iPhone 安全区域适配 */
        body {
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* Modal 底部安全区域 */
        .fixed.inset-0 > div {
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* 页面加载过渡，防止 FOUC */
        html:not(.loaded) body {
            opacity: 0;
        }
        html.loaded body {
            opacity: 1;
            transition: opacity 0.3s ease-out;
        }
        
        /* ========== 标题进入动画 ========== */
        @keyframes title-glitch-in {
            0% {
                opacity: 0;
                transform: translateX(-20px) skewX(-10deg);
                filter: blur(10px);
                clip-path: inset(0 100% 0 0);
            }
            30% {
                opacity: 1;
                transform: translateX(5px) skewX(5deg);
                filter: blur(0);
                clip-path: inset(0 0 0 0);
            }
            50% {
                transform: translateX(-3px) skewX(-2deg);
                text-shadow: 3px 0 var(--theme-primary), -3px 0 var(--theme-secondary);
            }
            70% {
                transform: translateX(2px) skewX(1deg);
                text-shadow: -2px 0 var(--theme-primary), 2px 0 var(--theme-secondary);
            }
            100% {
                transform: translateX(0) skewX(0);
                text-shadow: none;
            }
        }
        
        html.loaded .title-animate {
            animation: title-glitch-in 0.8s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }
        
        html:not(.loaded) .title-animate {
            opacity: 0;
        }
        
        /* ========== Tab 矩形开关容器 ========== */
        .tab-container {
            position: relative;
            display: flex;
            gap: 0;
            background: #111;
            padding: 4px;
            border: 2px solid #333;
        }
        
        /* 滑动高亮指示器 - 矩形 */
        .tab-indicator {
            position: absolute;
            top: 4px;
            bottom: 4px;
            background: var(--theme-primary);
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            box-shadow: 
                0 0 20px color-mix(in srgb, var(--theme-primary) 60%, transparent),
                0 0 40px color-mix(in srgb, var(--theme-primary) 30%, transparent);
        }
        
        .tab-btn {
            position: relative;
            z-index: 1;
        }
        
        .tab-btn.active {
            z-index: 2;
        }
        
        /* ========== 封条胶带滚动效果 (Marquee Tape) ========== */
        /* 单条封条 - 紧贴顶部导航栏下方，随页面滚动 */
        .marquee-tape {
            position: absolute;
            top: 52px;
            left: 0;
            right: 0;
            width: 100%;
            height: 32px;
            margin-bottom: 1rem;
            background: 
                linear-gradient(90deg, 
                    transparent 0%, 
                    rgba(255,255,255,0.05) 25%, 
                    transparent 50%,
                    rgba(0,0,0,0.05) 75%,
                    transparent 100%
                ),
                var(--theme-primary);
            overflow: hidden;
            z-index: 190;
            box-shadow: 
                0 4px 20px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.1),
                inset 0 -1px 0 rgba(0,0,0,0.2);
            pointer-events: auto;
            cursor: pointer;
            border-bottom: 2px solid rgba(0,0,0,0.3);
        }
        
        .marquee-tape:hover {
            filter: brightness(1.1);
        }
        
        @media (max-width: 768px) {
            .marquee-tape {
                top: 48px;
                height: 28px;
                margin-bottom: 0.75rem;
            }
        }
        
        .marquee-track {
            display: flex;
            animation: marquee-scroll 80s linear infinite;
            white-space: nowrap;
            width: fit-content;
        }
        
        .marquee-content {
            display: flex;
            align-items: center;
            height: 32px;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .marquee-content {
                height: 28px;
            }
        }
        
        .marquee-content span {
            font-family: "Arial Black", Impact, sans-serif;
            font-size: 24px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #000;
            padding: 0 20px;
        }
        
        .marquee-content span::after {
            content: "✦";
            margin-left: 20px;
            opacity: 0.5;
            font-size: 20px;
        }
        
        @keyframes marquee-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        /* 第二条胶带 - 隐藏 */
        .marquee-tape-2 {
            display: none;
        }
        
        /* 页面内容正常布局 */
        .main-content {
            padding-top: 50px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                padding-top: 45px;
            }
        }
        
        .marquee-track-reverse {
            display: flex;
            animation: marquee-scroll-reverse 35s linear infinite;
            white-space: nowrap;
        }
        
        .marquee-content-2 {
            display: flex;
            align-items: center;
            height: 44px;
        }
        
        .marquee-content-2 span {
            font-family: "Arial Black", Impact, sans-serif;
            font-size: 24px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #000;
            padding: 0 50px;
        }
        
        .marquee-content-2 span::after {
            content: "✦";
            margin-left: 50px;
            opacity: 0.3;
        }
        
        @keyframes marquee-scroll-reverse {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0); }
        }
        
        /* ========== 阶段F：背景氛围层 ========== */
        .ambient-layer {
            position: fixed;
            inset: 0;
            z-index: -8;
            pointer-events: none;
            opacity: 0.4;
            background: 
                radial-gradient(ellipse 80% 50% at 20% 80%, var(--theme-primary), transparent 50%),
                radial-gradient(ellipse 60% 40% at 80% 20%, var(--theme-secondary), transparent 50%);
            animation: ambient-drift 20s ease-in-out infinite alternate;
            filter: blur(80px);
        }
        
        @keyframes ambient-drift {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 0.3;
            }
            50% {
                transform: translate(-5%, 3%) scale(1.1);
                opacity: 0.5;
            }
            100% {
                transform: translate(5%, -3%) scale(1);
                opacity: 0.35;
            }
        }
        
        /* ========== 阶段G：页面过渡动画 ========== */
        /* 卡片入场动画 */
        .card-enter {
            opacity: 0;
            transform: translateY(20px);
            animation: card-fade-in 0.4s ease forwards;
        }
        
        @keyframes card-fade-in {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Tab 内容切换动画 */
        .view-transition {
            animation: view-fade-in 0.3s ease;
        }
        
        @keyframes view-fade-in {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* ========== 顶部固定导航栏 ========== */
        .sf6-top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            height: 52px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(180deg, rgba(10,10,10,0.98) 0%, rgba(5,5,5,0.95) 100%);
            border-bottom: 1px solid color-mix(in srgb, var(--theme-primary) 30%, transparent);
            box-shadow: 0 1px 20px rgba(0,0,0,0.5), 0 1px 0 color-mix(in srgb, var(--theme-primary) 15%, transparent);
            backdrop-filter: blur(10px);
        }
        
        .sf6-nav-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .sf6-nav-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            transition: opacity 0.2s;
        }
        
        .sf6-nav-logo:hover {
            opacity: 0.8;
        }
        
        .sf6-nav-logo img {
            width: 28px;
            height: 28px;
            object-fit: contain;
        }
        
        .sf6-nav-logo span {
            font-family: 'Syne', sans-serif;
            font-weight: 900;
            font-size: 1rem;
            letter-spacing: -0.05em;
            color: #fff;
        }
        
        @media (min-width: 768px) {
            .sf6-nav-logo span {
                font-size: 1.125rem;
            }
        }
        
        .sf6-nav-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sf6-nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 38px;
            height: 38px;
            background: rgba(0, 0, 0, 0.4);
            border: 1.5px solid var(--theme-primary);
            color: var(--theme-primary);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            clip-path: polygon(4px 0, 100% 0, calc(100% - 4px) 100%, 0 100%);
        }
        
        .sf6-nav-btn:hover {
            background: var(--theme-primary);
            color: #000;
            box-shadow: 0 0 15px var(--theme-primary);
        }
        
        .sf6-nav-btn svg {
            width: 18px;
            height: 18px;
        }
        
        /* ========== 全屏菜单 ========== */
        .sf6-fullscreen-menu {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.97);
            z-index: 300;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1.2rem;
        }
        
        .sf6-fullscreen-menu.active {
            display: flex;
        }
        
        .sf6-menu-close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 48px;
            height: 48px;
            background: transparent;
            border: 2px solid var(--theme-primary);
            color: var(--theme-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            clip-path: polygon(6px 0, 100% 0, calc(100% - 6px) 100%, 0 100%);
        }
        
        .sf6-menu-close-btn:hover {
            background: var(--theme-primary);
            color: #000;
            box-shadow: 0 0 20px var(--theme-primary);
        }
        
        .sf6-menu-close-btn svg {
            width: 26px;
            height: 26px;
        }
        
        .sf6-menu-link {
            font-family: 'Syne', sans-serif;
            font-size: clamp(1.6rem, 5vw, 3rem);
            font-weight: 900;
            font-style: italic;
            letter-spacing: -0.02em;
            color: #fff;
            text-decoration: none;
            text-transform: uppercase;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .sf6-menu-link:hover {
            color: var(--theme-primary);
            text-shadow: 
                0 0 20px var(--theme-primary),
                0 0 40px color-mix(in srgb, var(--theme-primary) 50%, transparent);
        }
        
        .sf6-menu-link.current {
            color: var(--theme-secondary);
            text-shadow: 0 0 15px var(--theme-secondary);
        }
        
        /* 菜单项装饰线 */
        .sf6-menu-link::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 50%;
            width: 0;
            height: 3px;
            background: var(--theme-primary);
            transform: translateY(-50%);
            transition: width 0.3s ease;
        }
        
        .sf6-menu-link:hover::before {
            width: 15px;
        }
        
        /* 移动端优化 */
        @media (max-width: 768px) {
            .sf6-top-nav {
                height: 48px;
                padding: 0 12px;
            }
            .sf6-nav-logo img {
                width: 24px;
                height: 24px;
            }
            .sf6-nav-btn {
                width: 34px;
                height: 34px;
            }
            .sf6-nav-btn svg {
                width: 16px;
                height: 16px;
            }
        }
    </style>
</head>
<body class="p-4 md:p-10 sf6-body">
    <!-- 顶部固定导航栏 -->
    <nav class="sf6-top-nav">
        <div class="sf6-nav-left">
            <a href="../" class="sf6-nav-logo" title="返回主页">
                <img src="../asset/logo-e.jpg" alt="E">
                <span>EMOBOI</span>
            </a>
        </div>
        <div class="sf6-nav-right">
            <span class="mono text-[10px] md:text-xs uppercase hidden sm:block" style="color: var(--theme-primary);">SF6 FRAME LAB</span>
            <a href="../" class="sf6-nav-btn sf6-nav-home-btn" title="返回主页">
            <i data-lucide="home"></i>
        </a>
        <button class="sf6-nav-btn" id="sf6MenuBtn" title="菜单">
            <i data-lucide="menu"></i>
        </button>
        </div>
    </nav>
    
    <!-- 全屏菜单 -->
    <div class="sf6-fullscreen-menu" id="sf6FullscreenMenu">
        <button class="sf6-menu-close-btn" id="sf6CloseMenu">
            <i data-lucide="x"></i>
        </button>
        <a href="../" class="sf6-menu-link">HOME</a>
        <a href="./" class="sf6-menu-link current">SF6 FRAME LAB</a>
        <a href="../gojuon/" class="sf6-menu-link">GOJUON</a>
        <a href="../gallery/" class="sf6-menu-link">MY GALLERY</a>
        <a href="javascript:void(0)" onclick="closeSf6Menu(); alert('开发中')" class="sf6-menu-link">I AM MUSIC</a>
    </div>
    
    <!-- 背景氛围层 -->
    <div class="ambient-layer"></div>
    
    <!-- 角色背景图层 -->
    <div id="bgOverlay" class="fixed inset-0 -z-10 bg-cover bg-center bg-no-repeat opacity-0 transition-opacity duration-500" style="background-position: center 20%;"></div>
    <div class="fixed inset-0 -z-10 bg-gradient-to-b from-black/90 via-black/80 to-black/70"></div>
    
    <!-- 封条胶带滚动效果 (Fixed 定位，横向无限) -->
    <div class="marquee-tape" id="marqueeTape1" onclick="openCharacterModal()" style="cursor: pointer;" title="点击切换角色">
        <div class="marquee-track">
            <div class="marquee-content" id="marqueeContent1"></div>
            <div class="marquee-content" id="marqueeContent1Clone"></div>
        </div>
    </div>
    <div class="marquee-tape-2">
        <div class="marquee-track-reverse">
            <div class="marquee-content-2" id="marqueeContent2"></div>
            <div class="marquee-content-2" id="marqueeContent2Clone"></div>
        </div>
    </div>
    
    <div class="max-w-6xl mx-auto main-content">
        <!-- HEADER -->
        <header class="flex flex-col sm:flex-row justify-between items-start sm:items-end gap-4 mb-16 border-b-2 border-zinc-800 pb-6">
                <div class="flex flex-col">
                <div class="flex items-center gap-3">
                    <h1 class="impact-text text-5xl sm:text-6xl tracking-tighter title-animate glitch-hover">SF6 FRAME LAB</h1>
                    <button onclick="openHelpModal()" class="group px-3 py-1 ml-1 bg-gradient-to-r from-cyan-600/20 to-pink-600/20 border border-cyan-500/50 hover:border-cyan-400 text-cyan-400 hover:text-cyan-300 text-xs font-bold tracking-wider uppercase transition-all hover:shadow-[0_0_15px_rgba(0,255,255,0.3)] flex items-center gap-1 whitespace-nowrap" title="使用说明">
                        <span class="text-sm">?</span>
                        <span>说明</span>
                    </button>
                </div>
            </div>
            <nav class="flex items-end gap-6 sm:gap-8 w-full sm:w-auto">
                <button onclick="openCharacterModal()" class="champion-btn uppercase flex items-center gap-2">
                    <span class="char-icon" id="currentCharIcon">🥋</span>
                    <span class="char-text">角色</span>
                </button>
                <div class="flex gap-1 sm:gap-2 tab-container relative ml-auto sm:ml-0" id="tabContainer">
                    <button onclick="switchTab('notes')" id="tab-notes" class="tab-btn active uppercase tracking-widest text-base sm:text-xl pb-2">方案</button>
                    <button onclick="switchTab('library')" id="tab-library" class="tab-btn uppercase tracking-widest text-base sm:text-xl pb-2">数据</button>
                    <div class="tab-indicator" id="tabIndicator"></div>
                </div>
            </nav>
        </header>

        <!-- VIEW: 方案 -->
        <div id="view-notes" class="space-y-6 pt-4">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-8">
                <h2 class="impact-text text-4xl sm:text-5xl font-black" style="color: var(--theme-secondary);">卡帧策略</h2>
                <div class="flex gap-2">
                    <button onclick="resetToDefault()" class="px-4 py-3 text-xs bg-zinc-800 text-zinc-500 hover:bg-zinc-700 hover:text-white transition-all font-bold">重置</button>
                    <button onclick="openNoteModal()" class="btn-hype px-6 sm:px-8 py-3 text-sm font-bold">+ 新增场景</button>
                </div>
            </div>
            
            <!-- 模块：打投择方案 -->
            <div class="mb-10">
                <h3 class="text-xl sm:text-2xl font-black text-zinc-300 mb-2 border-l-4 pl-4" style="border-color: var(--theme-primary);">打投择方案</h3>
                <p class="text-xs text-zinc-500 mb-4 pl-4">寻找能卡出特定有利帧（打投择时机）的场景 · 范围 6~50F</p>
                
                <!-- 折叠区域 -->
                <details class="trend-card" id="mixupDetails">
                    <summary class="px-5 py-3 cursor-pointer text-zinc-300 hover:text-white text-sm font-bold transition-colors select-none flex items-center gap-2">
                        <span class="text-zinc-500 text-xs mixup-arrow transition-transform duration-200">▶</span>
                        展开查看打投择方案
                    </summary>
                    <div class="px-5 pb-5 pt-3 border-t" style="border-color: var(--theme-card-border);">
                        <!-- Tab 切换 -->
                        <div class="flex gap-3 mb-4 border-b-2 pb-1" style="border-color: var(--theme-card-border);">
                            <button onclick="switchMixupTab(5)" id="mixupTab5" class="mixup-tab-btn active px-6 py-3 text-lg font-black transition-colors">5F</button>
                            <button onclick="switchMixupTab(4)" id="mixupTab4" class="mixup-tab-btn px-6 py-3 text-lg font-black transition-colors">4F</button>
                            <button onclick="switchMixupTab(3)" id="mixupTab3" class="mixup-tab-btn px-6 py-3 text-lg font-black transition-colors">3F</button>
                        </div>
                        
                        <!-- 内容区 -->
                        <div id="throwMixupContent" class="min-h-[80px]"></div>
                    </div>
                </details>
            </div>
            
            <!-- 模块：压制方案 -->
            <div>
                <h3 class="text-xl sm:text-2xl font-black text-zinc-300 mb-4 border-l-4 pl-4" style="border-color: var(--theme-primary);">压制方案</h3>
            </div>
            
            <!-- 搜索框和工具栏 - 始终同行 -->
            <div class="mb-6 flex flex-row gap-2 items-center">
                <div class="flex-1 relative min-w-0">
                    <input type="text" id="solutionSearch" 
                        class="w-full bg-black border border-zinc-700 px-3 py-2 pr-8 text-sm text-white placeholder-zinc-600 focus:border-cyan-500 focus:outline-none transition-colors"
                        placeholder="搜索帧数或情境..."
                        aria-label="搜索场景"
                        oninput="debounce(filterSolutions)(); updateClearBtn()">
                    <button id="clearSearchBtn" onclick="clearSearch()" 
                        class="absolute right-1.5 top-1/2 -translate-y-1/2 text-zinc-600 hover:text-white text-lg p-0.5 hidden transition-colors"
                        title="清除搜索">×</button>
                </div>
                <!-- 工具栏按钮组 -->
                <div class="flex gap-1.5 flex-shrink-0">
                <button onclick="toggleSortOrder()" id="sortOrderBtn" 
                        class="sort-btn px-2.5 py-2 border transition-all flex items-center gap-1 text-xs font-bold"
                    title="切换排序方向">
                    <span id="sortOrderIcon">↑</span>
                    <span id="sortOrderText" class="hidden sm:inline">帧数</span>
                </button>
                    <button onclick="toggleAllDetails()" id="toggleAllDetailsBtn" 
                        class="sort-btn px-2.5 py-2 border transition-all flex items-center gap-1 text-xs font-bold"
                        title="展开/收起所有详情">
                        <span id="toggleAllIcon" class="text-[10px] opacity-80">▼</span>
                        <span id="toggleAllText" class="hidden sm:inline">展开</span>
                    </button>
                    <button onclick="toggleShowOnlyFavorites()" id="showFavoritesBtn" 
                        class="sort-btn px-2.5 py-2 border transition-all flex items-center gap-1 text-xs font-bold"
                        title="只显示收藏方案">
                        <span id="showFavoritesIcon">☆</span>
                        <span id="showFavoritesText" class="hidden sm:inline">收藏</span>
                </button>
                </div>
            </div>
            <div id="noteListContainer" class="grid grid-cols-1 gap-6"></div>
            
            <!-- 收藏卡片视图 -->
            <div id="favoritesGridView" class="hidden">
                <div class="flex items-center justify-between mb-8 pb-4 border-b-2" style="border-color: var(--theme-primary);">
                    <div class="flex items-center gap-2 sm:gap-4 flex-wrap">
                        <span class="text-3xl sm:text-4xl" style="color: #facc15; filter: drop-shadow(0 0 8px rgba(250, 204, 21, 0.6));">★</span>
                        <div class="relative">
                            <button id="templateSelectorBtn" onclick="toggleTemplateDropdown()" class="flex items-center gap-2 text-xl sm:text-2xl lg:text-3xl font-black text-white hover:opacity-80 transition-opacity">
                                <span id="currentTemplateName">我的收藏</span>
                                <span class="text-base sm:text-lg" style="color: var(--theme-secondary);">▼</span>
                            </button>
                            <!-- 下拉菜单 -->
                            <div id="templateDropdown" class="hidden absolute top-full left-0 mt-2 bg-zinc-900 border-2 rounded-lg shadow-2xl z-50 min-w-[200px]" style="border-color: var(--theme-primary);">
                                <div id="templateDropdownList" class="py-2">
                                    <!-- 动态填充 -->
                                </div>
                            </div>
                        </div>
                        <span id="favoritesCount" class="text-base sm:text-lg font-bold" style="color: var(--theme-secondary);">(0)</span>
                        <button onclick="openTemplateManageModal()" class="text-zinc-400 hover:text-zinc-200 transition-colors p-1.5 text-sm" title="管理模板">
                            ✏️
                        </button>
                    </div>
                    <div class="flex items-center gap-2 sm:gap-3">
                        <button onclick="openImportExportModal()" class="px-3 sm:px-4 py-2 text-xs sm:text-sm bg-zinc-800 text-zinc-300 hover:bg-zinc-700 hover:text-white transition-all font-bold flex items-center gap-1.5 sm:gap-2 border border-zinc-600 hover:border-zinc-500">
                            导入/导出
                        </button>
                        <button onclick="toggleShowOnlyFavorites()" class="px-3 sm:px-5 py-2 text-xs sm:text-sm bg-zinc-800 text-zinc-300 hover:bg-zinc-700 hover:text-white transition-all font-bold flex items-center gap-1.5 sm:gap-2 border border-zinc-600 hover:border-zinc-500">
                            ← 返回列表
                        </button>
                    </div>
                </div>
                
                <!-- 压制方案收藏 -->
                <div id="favMeatySection" class="mb-10">
                    <div class="text-sm text-zinc-400 uppercase tracking-wider mb-5 border-b border-zinc-700 pb-3 font-bold">压制方案</div>
                    <div id="favMeatyGrid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-5"></div>
                </div>
                
                <!-- 打投择方案收藏 -->
                <div id="favMixupSection">
                    <div class="text-sm text-zinc-400 uppercase tracking-wider mb-5 border-b border-zinc-700 pb-3 font-bold">打投择方案</div>
                    <div id="favMixupGrid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-5"></div>
                </div>
                
                <!-- 空状态 -->
                <div id="favEmptyState" class="hidden text-center py-20">
                    <div class="text-6xl mb-6" style="color: #facc15; filter: drop-shadow(0 0 15px rgba(250, 204, 21, 0.4));">☆</div>
                    <div class="text-zinc-400 text-xl mb-3 font-bold">还没有收藏任何方案</div>
                    <div class="text-zinc-500">点击方案上的 ☆ 来添加收藏</div>
                </div>
            </div>
        </div>

        <!-- VIEW: 数据 -->
        <div id="view-library" class="hidden space-y-8">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-8 pt-4">
                <h2 class="impact-text text-4xl sm:text-5xl font-black" style="color: var(--theme-secondary);">角色数据</h2>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
                <div class="lg:col-span-4 bg-zinc-900 p-6 border border-zinc-800">
                    <!-- 新增招式按钮 -->
                    <button onclick="openAddMoveModal()" class="btn-secondary w-full py-2 mb-4 text-sm font-bold">
                        + 新增招式
                    </button>
                    
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="impact-text text-2xl font-black" style="color: var(--theme-primary);">批量导入</h3>
                        <button onclick="loadTemplate()" class="text-xs text-zinc-500 hover:text-cyan-400 underline transition-colors">
                            JSON 格式
                        </button>
                    </div>

                    <textarea id="rawPaste" class="w-full h-40 bg-black border border-zinc-700 p-4 text-xs font-mono text-cyan-500 resize-none" placeholder='粘贴 JSON 数据...'></textarea>
                    <button onclick="importJson()" class="btn-secondary w-full mt-4 py-2 text-sm font-bold">批量导入</button>
                    <button onclick="resetMovesToDefault()" class="w-full mt-2 py-2 bg-zinc-800 text-zinc-500 text-xs font-bold hover:bg-blue-900 hover:text-white transition-all">重置预设</button>
                </div>
                <div class="lg:col-span-8 overflow-x-auto relative bg-black/60 p-4 border border-zinc-800/50">
                    <!-- 移动端滚动提示 -->
                    <div class="lg:hidden text-[10px] text-zinc-600 text-right mb-1 italic">← 左右滑动查看 →</div>
                    <table class="w-full text-left min-w-[500px]">
                        <thead class="text-zinc-600 text-[10px] font-black uppercase tracking-widest border-b border-zinc-800">
                            <tr>
                                <th class="p-4">Name</th>
                                <th class="p-4 text-center">Start</th>
                                <th class="p-4 text-center">Active</th>
                                <th class="p-4 text-center">Recov</th>
                                <th class="p-4 text-center">Hit</th>
                                <th class="p-4 text-center">Blk</th>
                                <th class="p-4 w-10"></th>
                            </tr>
                        </thead>
                        <tbody id="moveTableBody" class="text-sm font-bold"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- 规则区域 -->
            <div class="mt-8 p-4 bg-zinc-900/50 border border-zinc-800/50">
                <div class="flex justify-between items-center mb-3">
                    <h4 class="text-sm font-bold text-zinc-400 uppercase tracking-widest">过滤规则</h4>
                    <div class="flex gap-2">
                        <button onclick="clearAllRules()" class="text-[10px] px-3 py-1.5 bg-zinc-800 text-zinc-500 hover:text-red-400 hover:bg-zinc-700 transition-all font-bold">清除全部</button>
                        <button onclick="openRuleModal()" class="text-[10px] px-3 py-1.5 bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700 transition-all font-bold">+ 添加规则</button>
                    </div>
                </div>
                <p class="text-[10px] text-zinc-600 mb-2">*全局规则不可删除 · 预设及自定义规则可删除</p>
                <div id="rulesContainer" class="space-y-1 text-xs"></div>
            </div>
        </div>
    </div>

    <!-- MODAL: Add Scenario -->
    <div id="noteModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm hidden flex items-center justify-center p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="noteModalTitle">
        <div class="bg-zinc-900 border w-full max-w-lg p-8 sm:p-10 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
            <div class="flex justify-between items-center mb-8">
                <h2 id="noteModalTitle" class="impact-text text-4xl sm:text-5xl font-black" style="color: var(--theme-modal-title);">新增场景</h2>
                <button onclick="closeModal()" class="text-zinc-500 hover:text-white text-3xl sm:text-2xl p-2 -m-2" title="关闭">&times;</button>
            </div>
            <div class="space-y-8">
                <div>
                    <div class="flex items-center justify-between mb-3">
                        <label class="block text-sm font-black uppercase text-zinc-400">初始有利帧</label>
                        <div class="fuzzy-switch-container" onclick="toggleFuzzyMode()" title="切换精确/模糊模式">
                            <span class="fuzzy-switch-label" id="fuzzyLabelExact">🎯 精确</span>
                            <div class="fuzzy-switch" id="fuzzySwitch">
                                <div class="fuzzy-switch-thumb"></div>
                            </div>
                            <span class="fuzzy-switch-label fuzzy-switch-label-inactive" id="fuzzyLabelFuzzy">模糊 🎲</span>
                        </div>
                    </div>
                    <!-- 精确模式输入 -->
                    <div id="exactInputGroup" class="adv-input-group">
                        <button type="button" onclick="adjustAdv(-1)" class="adv-btn">−</button>
                        <input type="text" id="inputAdv" inputmode="numeric" pattern="[0-9]*" maxlength="2"
                            class="adv-input" placeholder="40" oninput="sanitizeAdvInput(); updateExpectOptions()">
                        <button type="button" onclick="adjustAdv(1)" class="adv-btn">+</button>
                    </div>
                    <!-- 模糊模式输入 -->
                    <div id="fuzzyInputGroup" class="fuzzy-input-group hidden">
                        <input type="text" id="inputAdvMin" inputmode="numeric" pattern="[0-9]*" maxlength="2"
                            class="fuzzy-input" placeholder="35" oninput="sanitizeFuzzyInput('inputAdvMin'); calculateFuzzyPreview()">
                        <span class="fuzzy-separator">~</span>
                        <input type="text" id="inputAdvMax" inputmode="numeric" pattern="[0-9]*" maxlength="2"
                            class="fuzzy-input" placeholder="40" oninput="sanitizeFuzzyInput('inputAdvMax'); calculateFuzzyPreview()">
                    </div>
                    <p id="advHint" class="text-xs text-zinc-500 mt-2">范围 1~99</p>
                </div>
                <div>
                    <label class="block text-sm font-black uppercase mb-3 text-zinc-400">情境说明</label>
                    <input type="text" id="inputContext" class="w-full bg-black border p-4 text-base font-bold text-white" style="border-color: var(--theme-card-border);" placeholder="例如：2HK放倒">
                </div>
                
                <!-- 期望后续 - 进阶选项 -->
                <details id="expectDetails" class="border bg-zinc-900/50" style="border-color: var(--theme-card-border);">
                    <summary class="px-5 py-4 cursor-pointer text-zinc-400 hover:text-zinc-200 text-base font-bold transition-colors select-none flex items-center gap-2">
                        <span class="text-zinc-500 text-xs expect-arrow transition-transform duration-200">▶</span>
                        期望后续 (可选)
                    </summary>
                    <div class="p-5 border-t space-y-5" style="border-color: var(--theme-card-border);">
                        <!-- 模式选择 -->
                        <div class="flex gap-3">
                            <button type="button" onclick="setExpectMode('remain')" id="expectModeRemain" class="flex-1 py-3 text-sm font-bold transition-all text-white" style="background-color: var(--theme-btn-primary);">指定剩余帧数</button>
                            <button type="button" onclick="setExpectMode('move')" id="expectModeMove" class="flex-1 py-3 text-sm font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white">指定压制招式</button>
                        </div>
                        
                        <!-- 模式A：指定剩余帧数 -->
                        <div id="expectRemainPanel" class="space-y-4">
                            <div>
                                <label class="block text-sm font-black uppercase mb-2 text-zinc-400">期望剩余帧数</label>
                                <input type="number" id="inputExpectRemain" class="w-full bg-black border p-4 text-2xl font-black" style="border-color: var(--theme-card-border); color: var(--theme-input-accent);" value="5" oninput="calculateExpectPlan()">
                                <p class="text-xs text-zinc-500 mt-2">系统将计算如何卡帧到剩余这个帧数</p>
                            </div>
                        </div>
                        
                        <!-- 模式B：指定压制招式 -->
                        <div id="expectMovePanel" class="space-y-4 hidden">
                            <div>
                                <label class="block text-sm font-black uppercase mb-2 text-zinc-400">选择压制招式</label>
                                <select id="inputExpectMove" class="w-full bg-black border p-4 text-base font-bold" style="border-color: var(--theme-card-border); color: var(--theme-input-accent);" onchange="calculateExpectPlan()">
                                    <option value="">-- 选择招式 --</option>
                                </select>
                                <p class="text-xs text-zinc-500 mt-2">系统将计算如何卡帧使该招式能偷至少 1 帧</p>
                            </div>
                        </div>
                        
                        <!-- 计算结果预览 -->
                        <div id="expectResult" class="hidden">
                            <div class="text-sm font-black uppercase mb-3 text-zinc-400">计算结果</div>
                            <div id="expectResultContent" class="bg-black/50 border p-4 text-base" style="border-color: var(--theme-card-border);"></div>
                        </div>
                    </div>
                </details>
                
                <div class="flex gap-3">
                    <button onclick="saveNote()" class="flex-1 text-white py-4 font-bold text-base transition-all modal-btn-primary">计算方案</button>
                    <button onclick="closeModal()" class="px-6 py-4 bg-zinc-800 text-zinc-400 font-bold text-base hover:text-white transition-all">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL: Character Select -->
    <div id="charModal" class="fixed inset-0 bg-black/95 backdrop-blur-sm hidden flex items-center justify-center p-2 sm:p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="charModalTitle">
        <div class="bg-zinc-900 border w-full max-w-3xl p-4 sm:p-6 md:p-8 max-h-[85vh] sm:max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
            <div class="flex justify-between items-center mb-4 sm:mb-6">
                <h2 id="charModalTitle" class="impact-text text-xl sm:text-2xl md:text-3xl font-black" style="color: var(--theme-modal-title);">选择角色</h2>
                <button onclick="closeCharModal()" class="text-zinc-500 hover:text-white text-2xl sm:text-3xl p-2 -m-2" title="关闭">&times;</button>
            </div>
            <div class="char-grid" id="charGrid"></div>
        </div>
    </div>

    <!-- MODAL: Add Rule -->
    <div id="ruleModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm hidden flex items-center justify-center p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="ruleModalTitle">
        <div class="bg-zinc-900 border w-full max-w-md p-6 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
            <div class="flex justify-between items-center mb-4">
                <h2 id="ruleModalTitle" class="impact-text text-2xl sm:text-3xl font-black" style="color: var(--theme-modal-title);">添加规则</h2>
                <button onclick="closeRuleModal()" class="text-zinc-500 hover:text-white text-3xl sm:text-2xl p-2 -m-2" title="关闭">&times;</button>
            </div>
            
            <!-- 规则类型选择 Tab -->
            <div class="flex gap-2 mb-4 border-b border-zinc-800">
                <button onclick="switchRuleTab('disable')" id="ruleTab-disable" class="rule-tab-btn active px-4 py-2 text-xs font-bold transition-colors">
                    禁用压制
                </button>
                <button onclick="switchRuleTab('combo')" id="ruleTab-combo" class="rule-tab-btn px-4 py-2 text-xs font-bold transition-colors">
                    禁用组合
                </button>
                <button onclick="switchRuleTab('prefer')" id="ruleTab-prefer" class="rule-tab-btn px-4 py-2 text-xs font-bold transition-colors">
                    倾向压制
                </button>
            </div>
            
            <!-- 禁用压制规则表单 -->
            <div id="ruleForm-disable" class="space-y-4">
                <p class="text-zinc-500 text-xs mb-4">禁止特定招式用于卡帧或压制。</p>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">选择招式</label>
                    <select id="inputDisableMove" class="w-full bg-black border p-3 text-sm font-bold text-white" style="border-color: var(--theme-card-border);">
                        <option value="">-- 请选择招式 --</option>
                    </select>
                </div>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">禁用场景</label>
                    <select id="inputDisableUsage" class="w-full bg-black border p-3 text-sm text-white" style="border-color: var(--theme-card-border);">
                        <option value="kill">用于卡帧</option>
                        <option value="meaty_after_kill">用于卡帧后的压制</option>
                        <option value="meaty_direct">用于直接压制</option>
                    </select>
                    <div class="mt-2 text-[10px] text-zinc-600" id="disableUsageHint">
                        禁止此招式用于消耗有利帧
                    </div>
                </div>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">说明 (可选)</label>
                    <input type="text" id="inputDisableDesc" class="w-full bg-black border p-3 text-sm text-zinc-400" style="border-color: var(--theme-card-border);" placeholder="例如: 容易被反击">
                </div>
                <div class="flex gap-2 pt-2">
                    <button onclick="saveDisableRule()" class="flex-1 text-white py-3 font-bold text-sm transition-all modal-btn-primary">保存规则</button>
                    <button onclick="closeRuleModal()" class="px-4 py-3 bg-zinc-800 text-zinc-400 font-bold text-sm hover:text-white transition-all">取消</button>
                </div>
            </div>
            
            <!-- 禁用组合规则表单 -->
            <div id="ruleForm-combo" class="space-y-4 hidden">
                <p class="text-zinc-500 text-xs mb-4">禁止两个招式连续使用（间隔使用不受影响）。</p>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">招式 1</label>
                    <select id="inputComboMove1" class="w-full bg-black border p-3 text-sm font-bold text-white" style="border-color: var(--theme-card-border);">
                        <option value="">-- 请选择招式 --</option>
                    </select>
                </div>
                <div class="text-center text-zinc-600 text-xs">× 禁止连续使用 ×</div>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">招式 2</label>
                    <select id="inputComboMove2" class="w-full bg-black border p-3 text-sm font-bold text-white" style="border-color: var(--theme-card-border);">
                        <option value="">-- 请选择招式 --</option>
                    </select>
                </div>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">说明 (可选)</label>
                    <input type="text" id="inputComboDesc" class="w-full bg-black border p-3 text-sm text-zinc-400" style="border-color: var(--theme-card-border);" placeholder="例如: 连招不稳定">
                </div>
                <div class="flex gap-2 pt-2">
                    <button onclick="saveComboRule()" class="flex-1 text-white py-3 font-bold text-sm transition-all modal-btn-primary">保存规则</button>
                    <button onclick="closeRuleModal()" class="px-4 py-3 bg-zinc-800 text-zinc-400 font-bold text-sm hover:text-white transition-all">取消</button>
                </div>
            </div>
            
            <!-- 倾向压制规则表单 -->
            <div id="ruleForm-prefer" class="space-y-4 hidden">
                <p class="text-zinc-500 text-xs mb-4">让特定招式的压制方案优先推荐（从备选提升到推荐区）。</p>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">选择招式</label>
                    <select id="inputPreferMove" class="w-full bg-black border p-3 text-sm font-bold text-white" style="border-color: var(--theme-card-border);">
                        <option value="">-- 请选择招式 --</option>
                    </select>
                </div>
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">理由 (可选)</label>
                    <input type="text" id="inputPreferDesc" class="w-full bg-black border p-3 text-sm text-zinc-400" style="border-color: var(--theme-card-border);" placeholder="例如: 伤害高、确认简单">
                </div>
                <div class="flex gap-2 pt-2">
                    <button onclick="savePreferRule()" class="flex-1 text-white py-3 font-bold text-sm transition-all modal-btn-primary">保存规则</button>
                    <button onclick="closeRuleModal()" class="px-4 py-3 bg-zinc-800 text-zinc-400 font-bold text-sm hover:text-white transition-all">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL: Add Move -->
    <div id="addMoveModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm hidden flex items-center justify-center p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="addMoveModalTitle">
        <div class="bg-zinc-900 border w-full max-w-md p-6 sm:p-8 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
            <div class="flex justify-between items-center mb-6">
                <h2 id="addMoveModalTitle" class="impact-text text-3xl sm:text-4xl font-black" style="color: var(--theme-modal-title);">新增招式</h2>
                <button onclick="closeAddMoveModal()" class="text-zinc-500 hover:text-white text-3xl sm:text-2xl p-2 -m-2" title="关闭">&times;</button>
            </div>
            <div class="space-y-4">
                <!-- 招式类型选择 -->
                <div>
                    <label class="block text-[10px] font-black uppercase mb-2 text-zinc-500">招式类型</label>
                    <div class="flex gap-2">
                        <button type="button" onclick="setMoveType('normal')" id="moveTypeNormal" class="flex-1 py-2 text-xs font-bold transition-all text-white" style="background-color: var(--theme-btn-primary);">普通招式</button>
                        <button type="button" onclick="setMoveType('throw')" id="moveTypeThrow" class="flex-1 py-2 text-xs font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white">投技</button>
                        <button type="button" onclick="setMoveType('dash')" id="moveTypeDash" class="flex-1 py-2 text-xs font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white">Dash</button>
                    </div>
                </div>
                
                <!-- 招式名称 -->
                <div>
                    <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">招式名称</label>
                    <input type="text" id="inputMoveName" class="w-full bg-black border p-3 text-lg font-bold text-white uppercase" style="border-color: var(--theme-card-border);" placeholder="例如: 5HP, 2MK">
                </div>
                
                <!-- 普通招式/投技的帧数据 -->
                <div id="moveFrameFields" class="space-y-3">
                    <div class="grid grid-cols-3 gap-3">
                        <div>
                            <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Startup</label>
                            <input type="number" id="inputMoveStartup" class="w-full bg-black border p-2 text-center font-mono text-white" style="border-color: var(--theme-card-border);" placeholder="7">
                        </div>
                        <div>
                            <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Active</label>
                            <input type="text" id="inputMoveActive" class="w-full bg-black border p-2 text-center font-mono text-white" style="border-color: var(--theme-card-border);" placeholder="7-9">
                        </div>
                        <div>
                            <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Recovery</label>
                            <input type="number" id="inputMoveRecovery" class="w-full bg-black border p-2 text-center font-mono text-white" style="border-color: var(--theme-card-border);" placeholder="15">
                        </div>
                    </div>
                    <div id="moveHitBlockFields" class="grid grid-cols-2 gap-3">
                        <div>
                            <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Hit (命中)</label>
                            <input type="number" id="inputMoveHit" class="w-full bg-black border p-2 text-center font-mono text-cyan-400" style="border-color: var(--theme-card-border);" placeholder="+5">
                        </div>
                        <div>
                            <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Block (打防)</label>
                            <input type="number" id="inputMoveBlock" class="w-full bg-black border p-2 text-center font-mono text-pink-400" style="border-color: var(--theme-card-border);" placeholder="-2">
                        </div>
                    </div>
                    <div id="moveKnockdownField">
                        <label class="flex items-center gap-2 text-sm text-zinc-400 cursor-pointer">
                            <input type="checkbox" id="inputMoveKnockdown" class="w-4 h-4 accent-red-500">
                            <span>击倒技 (Knockdown)</span>
                        </label>
                    </div>
                </div>
                
                <!-- Dash 的帧数据 -->
                <div id="moveDashFields" class="hidden">
                    <div>
                        <label class="block text-[10px] font-black uppercase mb-1 text-zinc-500">Dash 总帧数</label>
                        <input type="number" id="inputMoveDashFrames" class="w-full bg-black border p-3 text-center font-mono text-white text-lg" style="border-color: var(--theme-card-border);" placeholder="19">
                    </div>
                </div>
                
                <div class="flex gap-2 pt-3">
                    <button onclick="saveNewMove()" class="flex-1 text-white py-3 font-bold text-sm transition-all modal-btn-primary">添加招式</button>
                    <button onclick="closeAddMoveModal()" class="px-4 py-3 bg-zinc-800 text-zinc-400 font-bold text-sm hover:text-white transition-all">取消</button>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL: Help -->
    <div id="helpModal" class="fixed inset-0 bg-black/95 backdrop-blur-sm hidden flex items-center justify-center p-4 z-50" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
        <div class="bg-zinc-900 border w-full max-w-2xl p-6 sm:p-8 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
            <div class="flex justify-between items-center mb-6">
                <h2 id="helpModalTitle" class="impact-text text-2xl sm:text-3xl font-black" style="color: var(--theme-modal-title);">使用说明</h2>
                <button onclick="closeHelpModal()" class="text-zinc-500 hover:text-white text-3xl sm:text-2xl p-2 -m-2" title="关闭">&times;</button>
            </div>
            <div class="space-y-6 text-zinc-300 text-sm leading-relaxed">
                <section>
                    <h3 class="text-lg font-bold text-white mb-2">📌 这是什么？</h3>
                    <p>SF6 FRAME LAB 是一款卡帧套路压制计算工具，帮助找到最优的<strong class="text-cyan-400">卡帧压制</strong>组合方案。</p>
                </section>
                
                <section>
                    <h3 class="text-lg font-bold text-white mb-2">🎮 如何使用</h3>
                    <ol class="list-decimal list-inside space-y-3 text-zinc-400">
                        <li><strong class="text-white">选择角色</strong> - 点击 <span class="text-cyan-400">角色</span> 按钮或顶部滚动横幅切换角色</li>
                        <li>
                            <strong class="text-white">查看卡帧策略</strong> - <span class="text-cyan-400">方案</span> 页签展示各种击倒情境下的最优方案
                            <p class="text-zinc-500 text-xs mt-1 ml-5">*使用搜索框查找特定帧数或场景，点击排序按钮切换排序方向</p>
                            <p class="text-zinc-500 text-xs ml-5">*点击 <span class="text-yellow-400">☆</span> 收藏喜欢的方案，点击 <span class="text-zinc-400">_</span> 最小化到备选区</p>
                        </li>
                        <li>
                            <strong class="text-white">新增场景</strong> - 点击 <span class="text-cyan-400">+ 新增场景</span> 输入有利帧数，系统自动计算
                            <p class="text-zinc-500 text-xs mt-1 ml-5">*切换「模糊」模式可输入帧数范围，系统计算通用方案</p>
                            <p class="text-zinc-500 text-xs ml-5">*可展开「期望后续」指定剩余帧数或压制招式，系统验证可行性</p>
                        </li>
                        <li>
                            <strong class="text-white">管理帧数据</strong> - <span class="text-cyan-400">数据</span> 页签可查看/导入角色招式数据
                            <p class="text-zinc-500 text-xs mt-1 ml-5">*管理组合规则：<span class="text-zinc-400">全局</span> 规则全角色生效，其他规则仅当前角色</p>
                        </li>
                    </ol>
                </section>
                
                <section>
                    <h3 class="text-lg font-bold text-white mb-2">💡 方案解读</h3>
                    <ul class="space-y-2 text-zinc-400">
                        <li><span class="text-yellow-500">卡帧招式</span> → 用来消耗多余的有利帧</li>
                        <li><span class="text-white">压制招式</span> → 对手起身时攻击命中的招式</li>
                        <li><span class="text-cyan-400">H +X</span> / <span class="text-white">H 0</span> / <span class="text-rose-400">H -X</span> → 命中时的帧数优势</li>
                        <li><span class="text-cyan-400">B +X</span> / <span class="text-white">B 0</span> / <span class="text-rose-400">B -X</span> →打防时的帧数优势</li>
                        <li><span class="text-emerald-400">偷 XF</span> → 比正常更早命中，多偷的帧数</li>
                    </ul>
                </section>
                
                <section>
                    <h3 class="text-lg font-bold text-white mb-2">⚙️ 规则管理</h3>
                    <p class="text-zinc-400 mb-2">在<span class="text-cyan-400">数据</span>页签可添加自定义规则：</p>
                    <ul class="space-y-2 text-zinc-400 text-sm">
                        <li><span class="text-red-400">禁用招式</span> → 禁止某招式用于卡帧、压制或直接压制</li>
                        <li><span class="text-red-400">禁止组合</span> → 禁止两个招式连续使用（如 5LP × 5LP）</li>
                        <li><span class="text-green-400">偏好压制</span> → 优先推荐某招式作为压制招式</li>
                    </ul>
                    <p class="text-zinc-500 text-xs mt-2">*<span class="text-zinc-400">全局</span>规则（如 LP+LP）对所有角色生效且不可删除</p>
                </section>
                
                <section>
                    <h3 class="text-lg font-bold text-white mb-2">📝 写在最后</h3>
                    <p class="text-zinc-400">本网页仍处于测试早期版本，如有反馈和建议，请B站私信 <strong class="text-cyan-400">Cold_Visions</strong>，十分感谢！</p>
                </section>
                
                <div class="pt-4 border-t border-zinc-800 text-center text-zinc-600 text-xs">
                    Made by Yuetian
                </div>
            </div>
        </div>
    </div>

    <!-- 角色数据存储（全局变量，由各角色JS文件填充） -->
    <script>const CHARACTER_DATA = {};</script>
    <!-- 加载角色数据文件 -->
    <script src="data/ryu.js"></script>
    <script src="data/blanka.js"></script>
    <script src="data/sagat.js"></script>
    <script src="data/juri.js"></script>

    <script>
        // ==================== 配置常量 ====================
        const CONFIG = {
            // SF6 全角色列表
            ALL_CHARACTERS: [
                "RYU", "LUKE", "KEN", "CHUN-LI", "GUILE", "KIMBERLY",
                "JURI", "JAMIE", "BLANKA", "DHALSIM", "E.HONDA", "DEE JAY",
                "MANON", "MARISA", "JP", "ZANGIEF", "LILY", "CAMMY",
                "RASHID", "A.K.I.", "ED", "GOUKI", "VEGA", "TERRY",
                "MAI", "ELENA", "SAGAT", "C.VIPER"
            ],
            // 已有JSON数据的角色
            CHARACTERS_WITH_DATA: ["RYU", "BLANKA", "SAGAT", "JURI"],
            // 安全跳所需帧数（大部分角色42F）
            SAFE_JUMP_FRAMES: {
                "DEFAULT": 42,
                "ZANGIEF": 43,
                "LILY": 44,
                "A.K.I.": 44,
                "CHUN-LI": 46,
                "DHALSIM": 75
            },
            // 全局规则（适用于所有角色，不可编辑）
            GLOBAL_RULES: [
                {
                    id: "global_lp_lp",
                    pattern1: "LP",
                    pattern2: "LP",
                    description: "轻拳不会和轻拳组合（连点取消不能精准卡帧）"
                },
                {
                    id: "global_2lp_2lp",
                    pattern1: "2LP",
                    pattern2: "2LP",
                    description: "下轻拳不会和下轻拳组合（连点取消不能精准卡帧）"
                },
                {
                    id: "global_2lp_lp",
                    pattern1: "2LP",
                    pattern2: "LP",
                    description: "下轻拳不会和轻拳组合（连点取消不能精准卡帧）"
                },
                {
                    id: "global_lp_2lp",
                    pattern1: "LP",
                    pattern2: "2LP",
                    description: "轻拳不会和下轻拳组合（连点取消不能精准卡帧）"
                }
            ],
            // 角色预设规则（角色专属，不可删除）
            CHARACTER_PRESET_RULES: {
                "RYU": [
                    {
                        id: "ryu_preset_5mk_meaty_after",
                        type: "disable",
                        moveName: "5MK",
                        usage: "meaty_after_kill",
                        description: "无法取消，不适合用于压制"
                    },
                    {
                        id: "ryu_preset_5mk_meaty_direct",
                        type: "disable",
                        moveName: "5MK",
                        usage: "meaty_direct",
                        description: "无法取消，不适合用于压制"
                    }
                ]
            },
            // 角色图标映射
            CHAR_ICONS: {
                "RYU": "🥋", "LUKE": "🥊", "KEN": "🔥", "CHUN-LI": "🦵", "GUILE": "✈️", "KIMBERLY": "🥷",
                "JURI": "🕷️", "JAMIE": "🍸", "BLANKA": "⚡", "DHALSIM": "🧘", "E.HONDA": "🤼", "DEE JAY": "🎵",
                "MANON": "🩰", "MARISA": "🗿", "JP": "🎩", "ZANGIEF": "🐻", "LILY": "🪶", "CAMMY": "🐱",
                "RASHID": "🌪️", "A.K.I.": "🐍", "ED": "👊", "GOUKI": "👹", "VEGA": "🦂", "TERRY": "🧢",
                "MAI": "🌸", "ELENA": "🌺", "SAGAT": "🐯", "C.VIPER": "🕶️"
            },
            // localStorage 键名前缀
            STORAGE_KEY: "sf6_frame_lab",
            // ==================== 角色主题配色方案 ====================
            // 【配色变量用途说明】
            // primary    - 主题色：卡片边框/背景混合、发光效果、按钮悬停背景
            // secondary  - 高亮文本色：帧数数字"+XXF"、大标题（必须是亮色！深色背景上的文字）
            // accent     - 点缀色：Glitch效果对比色、环境光、装饰元素
            // modalTitle - Modal对话框标题颜色
            // btnPrimary - 主按钮背景色
            // btnPrimaryHover - 主按钮悬停色
            // inputAccent - 输入框强调色
            // cardBg     - 卡片背景（深色）
            // cardBorder - 卡片边框颜色
            // bgImage    - 背景图片路径
            CHAR_THEMES: {
                "RYU": {
                    primary: "#6b2020",      // 道服暗红
                    secondary: "#d4a574",    // 道服米色（文本高亮）
                    accent: "#1a1a1a",       // 水墨黑（Glitch对比）
                    modalTitle: "#a04040",
                    btnPrimary: "#6b2020",
                    btnPrimaryHover: "#4a1515",
                    inputAccent: "#a04040",
                    cardBg: "#1a1210",       // 深棕红
                    cardBorder: "#3d2218",
                    bgImage: "asset/ryu_ss01.jpg"
                },
                "BLANKA": {
                    primary: "#228b22",      // 丛林绿
                    secondary: "#ffd700",    // 闪电黄（文本高亮）
                    accent: "#f97316",       // 毛发橙（Glitch对比）
                    modalTitle: "#32cd32",
                    btnPrimary: "#228b22",
                    btnPrimaryHover: "#1a6b1a",
                    inputAccent: "#32cd32",
                    cardBg: "#141c14",       // 深绿
                    cardBorder: "#2a4a2a",
                    bgImage: "asset/blanka_ss01.jpg"
                },
                "SAGAT": {
                    primary: "#d49500",      // 虎黄/沙金（饱满有力）
                    secondary: "#e8e4d8",    // 绑带亮灰白（文本高亮）
                    accent: "#e5a000",       // 虎黄（Glitch对比 - 和primary呼应）
                    modalTitle: "#e8e4d8",   // 绑带亮灰白
                    btnPrimary: "#b88000",   // 深沙金按钮
                    btnPrimaryHover: "#9a6a00",
                    inputAccent: "#d49500",  // 虎黄强调
                    cardBg: "#0a0a08",       // 纯黑（体现黑色次色调）
                    cardBorder: "#2a2820",   // 暗灰边框
                    bgImage: "asset/sagat_ss01.jpg"
                },
                "JURI": {
                    primary: "#9932cc",      // 深紫色（衣服主色）
                    secondary: "#ff1493",    // 玫红色（文本高亮，背景飞溅效果）
                    accent: "#00ced1",       // 青色（指甲、发饰点缀）
                    modalTitle: "#da70d6",   // 亮紫/兰花紫
                    btnPrimary: "#8b008b",   // 深玫红紫
                    btnPrimaryHover: "#6a006a",
                    inputAccent: "#ff69b4",  // 亮粉色
                    cardBg: "#150a14",       // 深紫黑
                    cardBorder: "#3d1a3d",   // 紫色边框
                    bgImage: "asset/juri_ss01.jpg"
                },
                // 默认主题（用于无特定主题的角色）
                "_DEFAULT": {
                    primary: "#ff007a",      // 霓虹粉
                    secondary: "#00f2ff",    // 青色（文本高亮）
                    accent: "#ffd700",       // 金色（Glitch对比）
                    modalTitle: "#ec4899",
                    btnPrimary: "#db2777",
                    btnPrimaryHover: "#be185d",
                    inputAccent: "#f472b6",
                    cardBg: "#141416",
                    cardBorder: "#2a2a2e",
                    bgImage: null
                }
            }
        };

        // ==================== 应用状态 ====================
        const state = {
            currentCharacter: "JURI",
            moveLibrary: [],
            notes: [],
            // 角色数据缓存：{ moves: [], scenarios: [] }
            characterCache: {},
            // 收藏的方案 { "charName:adv:planKey": true } - 旧版，保留用于迁移
            favorites: {},
            // 最小化的方案 { "charName:adv:planKey": true }
            minimized: {},
            // 排序方向：'asc' 从小到大，'desc' 从大到小
            sortOrder: 'asc',
            // 角色专属规则 { charName: [rules] }
            characterRules: {},
            // 已删除的预设规则 { "charName:ruleId": true }
            deletedPresetRules: {},
            // 当前展开的有利帧（Set，支持多个同时展开）
            expandedAdvSet: new Set(),
            // 全局展开详情开关
            allDetailsExpanded: false,
            // 是否只显示收藏方案
            showOnlyFavorites: false,
            // 打投择收藏 { "charName:adv:remain:killDesc": true } - 旧版，保留用于迁移
            mixupFavorites: {},
            // 打投择隐藏的方案 { "charName:adv:remain:killDesc": true }
            mixupHidden: {},
            // 收藏模板系统 { charName: { current: "my", templates: {...} } }
            favoriteTemplates: {},
            // 模板修改提示标记 { "charName:templateId": true }
            templateModifyWarned: {}
        };

        // ==================== 工具函数 ====================
        // HTML 转义，防止 XSS
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // 显示操作提示（轻量级 toast）
        function showToast(message, type = 'success') {
            // 移除已有的 toast
            const existing = document.getElementById('toast');
            if (existing) existing.remove();
            
            const toast = document.createElement('div');
            toast.id = 'toast';
            toast.className = `fixed bottom-20 left-1/2 -translate-x-1/2 px-4 py-2 rounded text-sm font-bold z-50 transition-all duration-300 ${
                type === 'success' ? 'bg-green-600 text-white' : 
                type === 'error' ? 'bg-red-600 text-white' : 
                'bg-zinc-700 text-white'
            }`;
            toast.textContent = message;
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(-50%) translateY(10px)';
            
            document.body.appendChild(toast);
            
            // 显示动画
            requestAnimationFrame(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(0)';
            });
            
            // 自动消失
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
                setTimeout(() => toast.remove(), 300);
            }, 1500);
        }
        
        // 搜索防抖
        let searchDebounceTimer = null;
        function debounce(func, delay = 150) {
            return function(...args) {
                clearTimeout(searchDebounceTimer);
                searchDebounceTimer = setTimeout(() => func.apply(this, args), delay);
            };
        }
        
        function getCharIcon(char) {
            return CONFIG.CHAR_ICONS[char] || "👤";
        }
        
        // 应用角色主题色
        function applyTheme(char) {
            const theme = CONFIG.CHAR_THEMES[char] || CONFIG.CHAR_THEMES["_DEFAULT"];
            const root = document.documentElement;
            
            root.style.setProperty('--theme-primary', theme.primary);
            root.style.setProperty('--theme-secondary', theme.secondary);
            root.style.setProperty('--theme-accent', theme.accent);
            root.style.setProperty('--theme-card-bg', theme.cardBg);
            root.style.setProperty('--theme-card-border', theme.cardBorder);
            root.style.setProperty('--theme-modal-title', theme.modalTitle);
            root.style.setProperty('--theme-btn-primary', theme.btnPrimary);
            root.style.setProperty('--theme-btn-primary-hover', theme.btnPrimaryHover);
            root.style.setProperty('--theme-input-accent', theme.inputAccent);
            root.style.setProperty('--theme-fuzzy', '#f59e0b');  // 模糊场景标签色（固定橙色）
            
            // 应用背景图
            const bgOverlay = document.getElementById('bgOverlay');
            if (theme.bgImage) {
                bgOverlay.style.backgroundImage = `url('${theme.bgImage}')`;
                bgOverlay.style.opacity = '1';
            } else {
                bgOverlay.style.backgroundImage = 'none';
                bgOverlay.style.opacity = '0';
            }
            
            console.log(`[主题] 应用 ${char} 主题:`, theme);
        }

        // 解析active字符串为段数组（支持多段如 "10-14,20-23"）
        function parseActiveRanges(activeStr) {
            if (typeof activeStr === 'number') return [{ start: activeStr, end: activeStr }];
            if (typeof activeStr !== 'string') return [{ start: 0, end: 0 }];
            
            return activeStr.split(',').map(segment => {
                const parts = segment.trim().split('-').map(Number);
                return {
                    start: parts[0],
                    end: parts.length === 2 ? parts[1] : parts[0]
                };
            });
        }

        // 获取最后一个active帧（用于计算卡帧招式的总耗时）
        function getLastActiveFrame(activeStr) {
            const ranges = parseActiveRanges(activeStr);
            return Math.max(...ranges.map(r => r.end));
        }

        // 检查targetFrame是否命中某个active段，返回命中信息或null
        // 对于两段招式：只有命中最后一段时才计算偷帧，命中第一段时偷帧为0
        function checkActiveHit(activeStr, targetFrame) {
            const ranges = parseActiveRanges(activeStr);
            const isMultiHit = ranges.length > 1;  // 是否是多段招式
            const lastRangeIndex = ranges.length - 1;
            
            for (let i = 0; i < ranges.length; i++) {
                const range = ranges[i];
                if (range.start <= targetFrame && targetFrame <= range.end) {
                    const isLastSegment = (i === lastRangeIndex);
                    // 两段招式：只有最后一段才计算偷帧，第一段偷帧为0
                    const effectiveStolen = (isMultiHit && !isLastSegment) ? 0 : (targetFrame - range.start);
                    
                    return {
                        hitAtActive: targetFrame - range.start + 1,
                        stolen: effectiveStolen,
                        rangeStart: range.start,
                        rangeEnd: range.end,
                        isMultiHit: isMultiHit,
                        isLastSegment: isLastSegment,
                        segmentIndex: i
                    };
                }
            }
            return null; // 未命中任何active段
        }

        // ==================== localStorage 存取 ====================
        function getStorageKey(char, type) {
            return `${CONFIG.STORAGE_KEY}_${char}_${type}`;
        }
        
        function getGlobalStorageKey(type) {
            return `${CONFIG.STORAGE_KEY}_global_${type}`;
        }

        // ========== 当前角色存储 ==========
        function saveCurrentCharacter(char) {
            try {
                localStorage.setItem(getGlobalStorageKey('currentCharacter'), char);
            } catch (e) {
                console.warn('保存当前角色失败:', e);
            }
        }
        
        function loadCurrentCharacter() {
            try {
                return localStorage.getItem(getGlobalStorageKey('currentCharacter')) || 'JURI';
            } catch (e) {
                return 'JURI';
            }
        }

        // ========== 招式数据存储 ==========
        function saveMoves(char, moves) {
            try {
                // 只保存用户修改过的数据（与预设不同）
                localStorage.setItem(getStorageKey(char, 'moves'), JSON.stringify(moves));
            } catch (e) {
                console.warn('保存招式数据失败:', e);
            }
        }
        
        function loadMovesFromStorage(char) {
            try {
                const saved = localStorage.getItem(getStorageKey(char, 'moves'));
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('读取招式数据失败:', e);
            }
            return null;
        }
        
        function clearSavedMoves(char) {
            localStorage.removeItem(getStorageKey(char, 'moves'));
        }

        // ========== Scenarios 存储 ==========
        // 保存角色的 scenarios 到 localStorage (只存储用户自定义的部分)
        function saveScenarios(char, allScenarios) {
            try {
                // 分离出用户自定义的场景（带有 isUserAdded 标记的）
                const userScenarios = allScenarios.filter(s => s.isUserAdded === true);
                localStorage.setItem(getStorageKey(char, 'scenarios'), JSON.stringify(userScenarios));
            } catch (e) {
                console.warn('保存 scenario 失败:', e);
            }
        }

        // 获取角色的预设 scenarios (从JSON缓存)
        function getDefaultScenarios(char) {
            const cache = state.characterCache[char];
            return cache?.scenarios ? [...cache.scenarios] : [];
        }
        
        // 获取角色的预设 moves (从JSON缓存)
        function getDefaultMoves(char) {
            const data = CHARACTER_DATA[char];
            return data?.moves ? [...data.moves] : [];
        }

        // 加载角色的 scenarios，合并预设 + 用户自定义
        function loadScenariosFromStorage(char) {
            try {
                const saved = localStorage.getItem(getStorageKey(char, 'scenarios'));
                if (saved) {
                    const userScenarios = JSON.parse(saved);
                    // 确保用户场景都有 isUserAdded 标记
                    userScenarios.forEach(s => s.isUserAdded = true);
                    return userScenarios;
                }
            } catch (e) {
                console.warn('读取 scenario 失败:', e);
            }
            return []; // 返回空数组表示没有用户自定义
        }

        // 加载完整的 scenarios：预设 + 用户自定义
        function loadAllScenarios(char) {
            const defaultScenarios = getDefaultScenarios(char);
            const userScenarios = loadScenariosFromStorage(char);
            return [...defaultScenarios, ...userScenarios];
        }

        // 重置角色 scenarios 为预设（清除用户自定义）
        function resetScenarios(char) {
            localStorage.removeItem(getStorageKey(char, 'scenarios'));
            return getDefaultScenarios(char);
        }
        
        // 重置角色 moves 为预设
        function resetMoves(char) {
            clearSavedMoves(char);
            return getDefaultMoves(char);
        }

        // ========== 规则存储 ==========
        // 保存角色专属规则
        function saveCharacterRules(char, rules) {
            try {
                localStorage.setItem(getStorageKey(char, 'rules'), JSON.stringify(rules));
            } catch (e) {
                console.warn('保存规则失败:', e);
            }
        }
        
        // 加载角色专属规则
        function loadCharacterRules(char) {
            try {
                const saved = localStorage.getItem(getStorageKey(char, 'rules'));
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('读取规则失败:', e);
            }
            return [];
        }
        
        // 获取当前角色的所有规则（全局 + 角色预设 + 用户自定义）
        function getAllRulesForCharacter(char) {
            const globalRules = CONFIG.GLOBAL_RULES.map(r => ({ ...r, isGlobal: true, isPreset: true }));
            // 角色预设规则，过滤掉已删除的
            const charPresetRules = (CONFIG.CHARACTER_PRESET_RULES[char] || [])
                .filter(r => !state.deletedPresetRules[`${char}:${r.id}`])
                .map(r => ({ ...r, isGlobal: false, isPreset: true }));
            const charRules = (state.characterRules[char] || []).map(r => ({ ...r, isGlobal: false, isPreset: false }));
            return [...globalRules, ...charPresetRules, ...charRules];
        }
        
        // 检查招式是否被禁用（用于特定用途）
        function isMoveDisabled(move, usage, rules) {
            if (!move) return false;
            const moveName = (move.name || '').toUpperCase();
            
            for (const rule of rules) {
                if (rule.type === 'disable' && rule.moveName && rule.usage === usage) {
                    if (moveName === rule.moveName.toUpperCase()) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // 检查两个招式是否被规则禁止组合
        function isComboForbidden(move1, move2, rules) {
            if (!move1 || !move2) return false;
            const name1 = (move1.name || '').toUpperCase();
            const name2 = (move2.name || '').toUpperCase();
            
            for (const rule of rules) {
                // 禁用组合规则
                if (rule.type === 'combo' && rule.move1 && rule.move2) {
                    const m1 = rule.move1.toUpperCase();
                    const m2 = rule.move2.toUpperCase();
                    // 双向检查
                    if ((name1 === m1 && name2 === m2) || (name1 === m2 && name2 === m1)) {
                        return true;
                    }
                }
                // 兼容旧的 pattern 规则（关键词匹配）
                else if (rule.pattern1 && rule.pattern2) {
                    const p1 = rule.pattern1.toUpperCase();
                    const p2 = rule.pattern2.toUpperCase();
                    if ((name1.includes(p1) && name2.includes(p2)) ||
                        (name1.includes(p2) && name2.includes(p1))) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // ========== 收藏/最小化状态存储 ==========
        function saveFavorites() {
            try {
                localStorage.setItem(getGlobalStorageKey('favorites'), JSON.stringify(state.favorites));
            } catch (e) {
                console.warn('保存收藏状态失败:', e);
            }
        }
        
        function loadFavorites() {
            try {
                const saved = localStorage.getItem(getGlobalStorageKey('favorites'));
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                return {};
            }
        }
        
        function saveMinimized() {
            try {
                localStorage.setItem(getGlobalStorageKey('minimized'), JSON.stringify(state.minimized));
            } catch (e) {
                console.warn('保存最小化状态失败:', e);
            }
        }
        
        function loadMinimized() {
            try {
                const saved = localStorage.getItem(getGlobalStorageKey('minimized'));
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                return {};
            }
        }

        // ==================== 核心计算逻辑 ====================
        // 获取角色的安全跳帧数要求
        function getSafeJumpFrames(character) {
            return CONFIG.SAFE_JUMP_FRAMES[character] || CONFIG.SAFE_JUMP_FRAMES["DEFAULT"];
        }
        
        // 检查方案是否为安全跳或伪安全跳
        // 返回: 'safe_jump' | 'pseudo_safe_jump' | null
        function checkSafeJump(plan, character) {
            if (!plan || plan.isThrow) return null;
            
            const safeJumpFrames = getSafeJumpFrames(character);
            
            // 直接压制时，remain 就是 adv（有利帧数本身）
            // 卡帧后，remain 是卡帧后剩余的帧数
            if (plan.remain === safeJumpFrames) {
                return 'safe_jump';
            } else if (plan.remain === safeJumpFrames - 1) {
                return 'pseudo_safe_jump';
            }
            
            return null;
        }
        
        // 获取偷帧数的颜色类（与 Hit/Block 帧数一致）
        function getStolenColorClass(stolen) {
            if (stolen >= 3) return 'text-green-400';      // 偷3帧以上，深绿
            if (stolen >= 1) return 'text-emerald-400';    // 偷1-2帧，浅绿
            return 'text-yellow-400';                       // 偷0帧，黄色
        }
        
        // 获取帧数优势的颜色类
        function getFrameColorClass(frames) {
            if (frames > 0) return 'text-cyan-400';         // 正帧，浅蓝
            if (frames === 0) return 'text-white';          // 0帧，白色
            return 'text-rose-400';                         // 负帧，玫瑰红
        }
        
        // 检测压制招式的攻击等级：heavy / medium / light / other
        function getMoveStrength(move) {
            if (!move || !move.name) return 'other';
            const name = move.name.toUpperCase();
            // 重攻击：HP, HK（包括带方向的如 6HP, 4HK 等）
            if (name.includes('HP') || name.includes('HK')) return 'heavy';
            // 中攻击：MP, MK
            if (name.includes('MP') || name.includes('MK')) return 'medium';
            // 轻攻击：LP, LK
            if (name.includes('LP') || name.includes('LK')) return 'light';
            return 'other';
        }
        
        // 获取方案的压制招式等级
        function getPlanStrength(plan) {
            return getMoveStrength(plan.meatyMove);
        }

        function calculateBestPlan(adv) {
            const possiblePlans = [];
            // 获取当前角色的所有规则
            const rules = getAllRulesForCharacter(state.currentCharacter);
            
            // ========== 方案A: 直接压制（不需要卡帧）==========
            // 对方在 adv+1 帧起身，检查是否有招式的 active 能覆盖
            const directTargetFrame = adv + 1;
            
            state.moveLibrary
                .filter(m => !m.isDash && m.active)
                .filter(m => !isMoveDisabled(m, 'meaty_direct', rules))  // 过滤被禁用的直接压制招式
                .forEach(meatyMove => {
                    // 使用新的多段active检查函数
                    const hitInfo = checkActiveHit(meatyMove.active, directTargetFrame);
                    
                    if (hitInfo) {
                        // 投技特殊处理：没有 hit/block 概念
                        const isThrowPlan = meatyMove.isThrow === true;
                        
                        possiblePlans.push({
                            isDirect: true,  // 标记为直接压制
                            isThrow: isThrowPlan,  // 标记是否为投技方案
                            killMove: null,
                            killTotal: 0,
                            remain: adv,
                            meatyMove,
                            stolen: hitInfo.stolen,
                            finalHit: isThrowPlan ? null : (meatyMove.hit || 0) + hitInfo.stolen,
                            finalBlock: isThrowPlan ? null : (meatyMove.block || 0) + hitInfo.stolen
                        });
                    }
                });
            
            // ========== 方案B: 卡帧后压制 ==========
            state.moveLibrary.forEach(killMove => {
                // 检查是否被禁用用于卡帧
                if (isMoveDisabled(killMove, 'kill', rules)) return;
                
                // Dash 只能卡帧，没有 active 判断
                if (killMove.isDash) {
                    const killTotal = killMove.dashFrames || 19;
                    if (killTotal >= adv) return;
                    
                    const remain = adv - killTotal;
                    const targetFrame = remain + 1;
                    
                    // Dash 后接压制招式
                    state.moveLibrary
                        .filter(m => !m.isDash && m.active)
                        .filter(m => !isMoveDisabled(m, 'meaty_after_kill', rules))  // 过滤被禁用的卡帧后压制招式
                        .forEach(meatyMove => {
                            const hitInfo = checkActiveHit(meatyMove.active, targetFrame);
                            if (hitInfo) {
                                const isThrowPlan = meatyMove.isThrow === true;
                                possiblePlans.push({
                                    isDirect: false,
                                    isThrow: isThrowPlan,
                                    killMove,
                                    killMove2: null,  // 单步卡帧无第二步
                                    killTotal,
                                    killTotal2: 0,
                                    remain,
                                    meatyMove,
                                    stolen: hitInfo.stolen,
                                    finalHit: isThrowPlan ? null : (meatyMove.hit || 0) + hitInfo.stolen,
                                    finalBlock: isThrowPlan ? null : (meatyMove.block || 0) + hitInfo.stolen
                                });
                            }
                        });
                    return;
                }
                
                if (!killMove.active) return;
                
                // 普通招式卡帧
                const lastActive = getLastActiveFrame(killMove.active);
                const killTotal = lastActive + killMove.recovery;

                if (killTotal >= adv) return;

                const remain = adv - killTotal;
                const targetFrame = remain + 1;
                
                state.moveLibrary
                    .filter(m => !m.isDash && m.active)
                    .filter(m => !isMoveDisabled(m, 'meaty_after_kill', rules))  // 过滤被禁用的卡帧后压制招式
                    .forEach(meatyMove => {
                        const hitInfo = checkActiveHit(meatyMove.active, targetFrame);
                        
                        if (hitInfo) {
                            // 使用规则系统检查是否禁止组合
                            if (isComboForbidden(killMove, meatyMove, rules)) {
                                return;
                            }
                            
                            const isThrowPlan = meatyMove.isThrow === true;
                            possiblePlans.push({
                                isDirect: false,
                                isThrow: isThrowPlan,
                                killMove,
                                killMove2: null,  // 单步卡帧无第二步
                                killTotal,
                                killTotal2: 0,
                                remain,
                                meatyMove,
                                stolen: hitInfo.stolen,
                                finalHit: isThrowPlan ? null : (meatyMove.hit || 0) + hitInfo.stolen,
                                finalBlock: isThrowPlan ? null : (meatyMove.block || 0) + hitInfo.stolen
                            });
                        }
                    });
            });

            // ========== 方案C: 两步卡帧后压制 ==========
            state.moveLibrary.forEach(killMove1 => {
                // 检查第一步是否被禁用用于卡帧
                if (isMoveDisabled(killMove1, 'kill', rules)) return;
                
                // 计算第一步卡帧消耗
                let killTotal1;
                if (killMove1.isDash) {
                    killTotal1 = killMove1.dashFrames || 19;
                } else if (killMove1.active) {
                    const lastActive1 = getLastActiveFrame(killMove1.active);
                    killTotal1 = lastActive1 + killMove1.recovery;
                } else {
                    return;
                }
                
                if (killTotal1 >= adv) return;
                const remain1 = adv - killTotal1;
                
                // 遍历第二步卡帧招式
                state.moveLibrary.forEach(killMove2 => {
                    // 检查第二步是否被禁用用于卡帧
                    if (isMoveDisabled(killMove2, 'kill', rules)) return;
                    
                    // 计算第二步卡帧消耗
                    let killTotal2;
                    if (killMove2.isDash) {
                        killTotal2 = killMove2.dashFrames || 19;
                    } else if (killMove2.active) {
                        const lastActive2 = getLastActiveFrame(killMove2.active);
                        killTotal2 = lastActive2 + killMove2.recovery;
                    } else {
                        return;
                    }
                    
                    if (killTotal2 >= remain1) return;
                    const remain2 = remain1 - killTotal2;
                    const targetFrame2 = remain2 + 1;
                    
                    // 使用规则系统检查第一步+第二步是否禁止组合
                    if (isComboForbidden(killMove1, killMove2, rules)) {
                        return;
                    }
                    
                    // 找压制招式
                    state.moveLibrary
                        .filter(m => !m.isDash && m.active)
                        .filter(m => !isMoveDisabled(m, 'meaty_after_kill', rules))  // 过滤被禁用的卡帧后压制招式
                        .forEach(meatyMove => {
                            const hitInfo = checkActiveHit(meatyMove.active, targetFrame2);
                            
                            if (hitInfo) {
                                // 使用规则系统检查第二步+压制是否禁止组合
                                if (isComboForbidden(killMove2, meatyMove, rules)) {
                                    return;
                                }
                                
                                const isThrowPlan = meatyMove.isThrow === true;
                                possiblePlans.push({
                                    isDirect: false,
                                    isThrow: isThrowPlan,
                                    killMove: killMove1,
                                    killMove2: killMove2,  // 两步卡帧
                                    killTotal: killTotal1,
                                    killTotal2: killTotal2,
                                    remain: remain2,
                                    meatyMove,
                                    stolen: hitInfo.stolen,
                                    finalHit: isThrowPlan ? null : (meatyMove.hit || 0) + hitInfo.stolen,
                                    finalBlock: isThrowPlan ? null : (meatyMove.block || 0) + hitInfo.stolen
                                });
                            }
                        });
                });
            });

            // ========== 标记两步卡帧是否可交换顺序 ==========
            // 检测每个两步卡帧方案，如果反向组合也存在，则标记为可交换
            possiblePlans.forEach(plan => {
                if (plan.killMove2) {
                    // 检查是否存在反向组合（killMove2 → killMove1 → 同样的压制）
                    const hasReverse = possiblePlans.some(otherPlan => 
                        otherPlan.killMove2 &&
                        otherPlan !== plan &&
                        otherPlan.killMove.name === plan.killMove2.name &&
                        otherPlan.killMove2.name === plan.killMove.name &&
                        otherPlan.meatyMove.name === plan.meatyMove.name &&
                        otherPlan.remain === plan.remain
                    );
                    // 标记是否可交换
                    plan.isCommutative = hasReverse;
                }
            });

            // 按 finalBlock 降序，再按 finalHit 降序（投技方案排在普通方案之后）
            return possiblePlans.sort((a, b) => {
                // 投技方案统一放后面
                if (a.isThrow !== b.isThrow) return a.isThrow ? 1 : -1;
                // 非投技方案：按 block > hit 排序
                if (!a.isThrow && !b.isThrow) {
                    if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                    return b.finalHit - a.finalHit;
                }
                // 投技方案：直接压制优先
                return (b.isDirect ? 1 : 0) - (a.isDirect ? 1 : 0);
            });
        }

        // ==================== 数据加载 ====================
        // 从全局 CHARACTER_DATA 加载角色数据（由外部 .js 文件填充）
        function loadCharacterData(char) {
            console.log(`[加载] 角色: ${char}`);
            
            // 1. 优先从 localStorage 加载用户保存的数据
            const savedMoves = loadMovesFromStorage(char);
            if (savedMoves && savedMoves.length > 0) {
                console.log(`[localStorage] 使用用户保存的招式数据: ${savedMoves.length} 个`);
                state.moveLibrary = savedMoves;
                state.characterCache[char] = {
                    moves: savedMoves,
                    scenarios: CHARACTER_DATA[char]?.scenarios || []
                };
                return true;
            }
            
            // 2. 检查内存缓存
            if (state.characterCache[char]?.moves?.length > 0) {
                console.log(`[缓存] 使用缓存数据`);
                state.moveLibrary = [...state.characterCache[char].moves];
                return true;
            }

            // 3. 从全局变量读取（由 <script src="xxx.js"> 加载）
            const data = CHARACTER_DATA[char];
            
            if (data && data.moves) {
                state.characterCache[char] = {
                    moves: [...data.moves],
                    scenarios: data.scenarios ? [...data.scenarios] : []
                };
                state.moveLibrary = [...data.moves];
                console.log(`[成功] 加载预设 ${data.moves.length} 个招式, ${data.scenarios?.length || 0} 个场景`);
                return true;
            } else {
                console.warn(`[警告] 未找到 ${char} 的数据，请确保已加载对应的 .js 文件`);
                state.moveLibrary = [];
                state.characterCache[char] = { moves: [], scenarios: [] };
                return false;
            }
        }

        // ==================== 角色切换 ====================
        function selectCharacter(char) {
            // 检查是否有数据，无数据角色不可选
            const hasData = CONFIG.CHARACTERS_WITH_DATA.includes(char);
            if (!hasData) {
                console.log(`[角色] ${char} 暂无数据，无法选择`);
                return; // 阻止选择
            }
            
            state.currentCharacter = char;
            
            // 清空展开状态
            state.expandedAdvSet.clear();
            state.allDetailsExpanded = false;
            updateToggleAllBtn();
            
            // 重置收藏视图状态
            if (state.showOnlyFavorites) {
                state.showOnlyFavorites = false;
                // 显示正常列表，隐藏收藏视图
                const normalView = document.getElementById('noteListContainer');
                const favView = document.getElementById('favoritesGridView');
                const viewNotes = document.getElementById('view-notes');
                
                if (viewNotes) {
                    Array.from(viewNotes.children).forEach(el => {
                        if (el.id !== 'noteListContainer' && el.id !== 'favoritesGridView') {
                            el.classList.remove('hidden');
                        }
                    });
                }
                
                normalView?.classList.remove('hidden');
                favView?.classList.add('hidden');
            }
            updateShowFavoritesBtn();
            
            // 保存当前角色选择到 localStorage
            saveCurrentCharacter(char);
            
            // 应用角色主题
            applyTheme(char);
            
            // 更新UI - 只更新图标
            document.getElementById('currentCharIcon').textContent = getCharIcon(char);
            
            // 加载角色数据 (moves + scenarios)
            loadCharacterData(char);
            
            // 加载 scenarios: 预设 + 用户自定义
            state.notes = loadAllScenarios(char);
            
            // 加载角色专属规则
            state.characterRules[char] = loadCharacterRules(char);
            
            // 更新封条滚动内容
            updateMarqueeTape();
            
            closeCharModal();
            renderAll();
            
            // 自动触发标题 Glitch 效果
            triggerTitleGlitch();
            // 触发角色按钮动画
            triggerCharBtnAnimation();
        }
        
        // 触发标题 Glitch 效果
        function triggerTitleGlitch() {
            const title = document.querySelector('.glitch-hover');
            if (title) {
                title.classList.add('glitch-active');
                setTimeout(() => {
                    title.classList.remove('glitch-active');
                }, 1000);
            }
        }
        
        // 触发角色按钮动画
        function triggerCharBtnAnimation() {
            const btn = document.querySelector('.champion-btn');
            if (btn) {
                btn.classList.remove('char-switch-active');
                // 强制重绘以重新触发动画
                void btn.offsetWidth;
                btn.classList.add('char-switch-active');
                setTimeout(() => {
                    btn.classList.remove('char-switch-active');
                }, 800);
            }
        }

        function initCharacterGrid() {
            const grid = document.getElementById('charGrid');
            grid.innerHTML = CONFIG.ALL_CHARACTERS.map(char => {
                const hasData = CONFIG.CHARACTERS_WITH_DATA.includes(char);
                const isSelected = char === state.currentCharacter;
                
                // 无数据角色不添加点击事件
                const clickHandler = hasData ? `onclick="selectCharacter('${char}')"` : '';
                
                return `
                    <div class="char-item ${isSelected ? 'selected' : ''} ${!hasData ? 'no-data' : ''}" 
                         ${clickHandler}
                         title="${hasData ? '点击选择' : '暂无数据'}">
                        <div class="char-icon">${getCharIcon(char)}</div>
                        <div class="char-name">${char}</div>
                    </div>
                `;
            }).join('');
        }

        // ==================== 渲染函数 ====================
        // 转义字符串以安全嵌入到JS字符串中（防止XSS）
        function escapeJsString(str) {
            if (!str) return '';
            return str.replace(/\\/g, '\\\\')
                      .replace(/'/g, "\\'")
                      .replace(/"/g, '\\"')
                      .replace(/`/g, '\\`')
                      .replace(/\$/g, '\\$');
        }
        
        // 生成方案唯一标识（用于去重）
        function getPlanKey(plan) {
            if (!plan) return '';
            const kill1Name = plan.killMove ? plan.killMove.name : 'DIRECT';
            const kill2Name = plan.killMove2 ? plan.killMove2.name : '';
            return `${kill1Name}|${kill2Name}|${plan.meatyMove.name}`;
        }
        
        // 获取安全的planKey（用于嵌入HTML属性）
        function getSafePlanKey(plan) {
            return escapeJsString(getPlanKey(plan));
        }

        // 生成推荐理由说明文本
        function getRecommendReasons(plan, reasons) {
            if (!reasons || reasons.length === 0) return '';
            
            const reasonTexts = {
                'safe_jump': '🦘 安全跳压制，防5帧及以上凹招',
                'pseudo_safe_jump': '🦘 伪安全跳压制，防6帧及以上凹招',
                'best_block': '🛡️ 打防收益最优',
                'best_hit': '⚔️ 命中收益最优',
                'best_nonheavy_block': '🎯 中/弱攻击打防最优',
                'best_nonheavy_hit': '🎯 中/弱攻击命中最优',
                'most_stolen': '⏱️ 偷帧最多',
                'throw': '🤼 投技方案',
                'mixup': '🎲 打投二择',
                'favorite': '⭐ 用户收藏',
                'prefer': '👍 用户规则倾向压制'  // 动态添加招式名
            };
            
            // 过滤规则：如果同时满足1和3，只显示1；同时满足2和4，只显示2
            let filteredReasons = [...reasons];
            if (reasons.includes('best_block') && reasons.includes('best_nonheavy_block')) {
                filteredReasons = filteredReasons.filter(r => r !== 'best_nonheavy_block');
            }
            if (reasons.includes('best_hit') && reasons.includes('best_nonheavy_hit')) {
                filteredReasons = filteredReasons.filter(r => r !== 'best_nonheavy_hit');
            }
            
            return filteredReasons.map(r => {
                if (r.startsWith('prefer:')) {
                    const moveName = r.split(':')[1];
                    return `👍 用户规则倾向压制：${moveName}`;
                }
                return reasonTexts[r] || '';
            }).filter(t => t).join('\n');
        }

        // 生成方案复制文本
        function generatePlanCopyText(plan, adv, label) {
            // 获取所有场景描述，用"/"连接多个场景
            const contexts = state.notes.filter(n => n.adv === adv && n.context).map(n => n.context);
            const contextStr = contexts.length > 0 ? contexts.join('/') : '';
            
            // 生成方案描述
            let planDesc;
            if (plan.isDirect) {
                planDesc = `直接 ${plan.meatyMove.name}`;
            } else if (plan.killMove2) {
                const separator = plan.isCommutative ? '+' : '→';
                planDesc = `${plan.killMove.name}${separator}${plan.killMove2.name}→${plan.meatyMove.name}`;
            } else {
                planDesc = `${plan.killMove.name}→${plan.meatyMove.name}`;
            }
            
            // 根据标签类型生成不同格式
            let result;
            if (label === '打投择') {
                result = `+${adv}F ${contextStr}：${planDesc} —— ${plan.remain}F 打投择`;
            } else if (plan.isThrow) {
                result = `+${adv}F ${contextStr}：${planDesc} —— 投技放倒`;
            } else {
                const hitStr = plan.finalHit >= 0 ? `+${plan.finalHit}` : plan.finalHit;
                const blockStr = plan.finalBlock >= 0 ? `+${plan.finalBlock}` : plan.finalBlock;
                result = `+${adv}F ${contextStr}：${planDesc} —— 偷${plan.stolen}F，打中${hitStr}，打防${blockStr}`;
            }
            
            // 转义特殊字符，确保安全
            return result.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
        }
        
        // 复制方案信息到剪贴板
        function copyPlanInfo(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('已复制方案信息');
            }).catch(err => {
                console.error('复制失败:', err);
                showToast('复制失败');
            });
        }

        // 渲染主要方案（紧凑版，带收藏和最小化按钮）
        function renderMainPlan(plan, label, adv, reasons = []) {
            if (!plan) return '';
            
            const planKey = getPlanKey(plan);
            const safePlanKey = getSafePlanKey(plan);  // 用于嵌入HTML
            const isFavorite = isPlanFavorite(adv, planKey);
            const isThrow = plan.isThrow;
            const accentColor = 'text-white';
            
            // 检查是否为安全跳/伪安全跳
            const isSafeJump = reasons.includes('safe_jump');
            const isPseudoSafeJump = reasons.includes('pseudo_safe_jump');
            const safeJumpLabel = isSafeJump ? '安全跳' : (isPseudoSafeJump ? '伪安全跳' : null);
            const safeJumpColor = isSafeJump ? 'text-green-400' : 'text-yellow-400';
            
            // 生成推荐理由提示
            const recommendReasons = getRecommendReasons(plan, reasons);
            const tooltipHtml = recommendReasons ? `<div class="recommend-tooltip">${recommendReasons.replace(/\n/g, '<br>')}</div>` : '';
            
            // 安全跳使用特殊边框颜色
            let borderColor, bgColor;
            if (isFavorite) {
                borderColor = 'border-yellow-500';
                bgColor = 'bg-yellow-900/10';
            } else if (isSafeJump) {
                borderColor = 'border-green-600';
                bgColor = 'bg-green-900/10';
            } else if (isPseudoSafeJump) {
                borderColor = 'border-yellow-600';
                bgColor = 'bg-yellow-900/5';
            } else {
                borderColor = 'border-zinc-800';
                bgColor = 'bg-zinc-900/50';
            }
            
            let stepsHtml;
            
            const stolenColor = getStolenColorClass(plan.stolen);
            
            if (plan.isDirect) {
                // 直接压制/投
                stepsHtml = `<div class="text-center">
                       <div class="text-[9px] text-zinc-600 uppercase mb-1">直接${isThrow ? '投' : ''} (${plan.remain}F)</div>
                       <div class="impact-text text-4xl sm:text-5xl font-black ${accentColor} leading-none glitch-text">${plan.meatyMove.name}</div>
                       ${!isThrow ? `<div class="text-xs mt-1"><span class="text-zinc-500">偷</span><span class="${stolenColor} font-bold">${plan.stolen}F</span></div>` : ''}
                   </div>`;
            } else if (plan.killMove2) {
                // 两步卡帧
                const remain1 = adv - plan.killTotal;
                const separator = plan.isCommutative ? '+' : '→';  // 可交换用+，有顺序限制用→
                
                // 安全跳时最后显示"安全跳"而不是招式名
                const finalDisplay = safeJumpLabel 
                    ? `<div class="impact-text text-xl sm:text-2xl font-black ${safeJumpColor} leading-none">${safeJumpLabel}</div>`
                    : `<div class="impact-text text-xl sm:text-2xl font-black ${accentColor} leading-none glitch-text">${plan.meatyMove.name}</div>
                       ${!isThrow ? `<div class="text-[9px]"><span class="text-zinc-500">偷</span><span class="${stolenColor} font-bold">${plan.stolen}F</span></div>` : ''}`;
                
                stepsHtml = `<div class="flex items-center justify-center gap-2 sm:gap-3 flex-wrap">
                       <div class="text-center min-w-[55px]">
                           <div class="impact-text text-xl sm:text-2xl font-black text-white leading-none">${plan.killMove.name}</div>
                           <div class="text-[9px] text-zinc-500">-${plan.killTotal}F</div>
                       </div>
                       <div class="text-center">
                           <div class="text-zinc-600 text-lg">${separator}</div>
                           <div class="text-[9px] text-yellow-500">${remain1}F</div>
                       </div>
                       <div class="text-center min-w-[55px]">
                           <div class="impact-text text-xl sm:text-2xl font-black text-white leading-none">${plan.killMove2.name}</div>
                           <div class="text-[9px] text-zinc-500">-${plan.killTotal2}F</div>
                       </div>
                       <div class="text-zinc-600 text-lg">→</div>
                       <div class="text-center min-w-[55px]">
                           ${finalDisplay}
                       </div>
                   </div>`;
            } else {
                // 一步卡帧
                // 安全跳时最后显示"安全跳"而不是招式名
                const finalDisplay = safeJumpLabel 
                    ? `<div class="impact-text text-2xl sm:text-4xl font-black ${safeJumpColor} leading-none">${safeJumpLabel}</div>`
                    : `<div class="impact-text text-2xl sm:text-4xl font-black ${accentColor} leading-none glitch-text">${plan.meatyMove.name}</div>
                       ${!isThrow ? `<div class="text-[10px]"><span class="text-zinc-500">偷</span><span class="${stolenColor} font-bold">${plan.stolen}F</span></div>` : ''}`;
                
                stepsHtml = `<div class="flex items-center justify-center gap-3 sm:gap-5">
                       <div class="text-center min-w-[70px]">
                           <div class="impact-text text-2xl sm:text-4xl font-black text-white leading-none">${plan.killMove.name}</div>
                           <div class="text-[10px] text-zinc-500">-${plan.killTotal}F</div>
                       </div>
                       <div class="text-center">
                           <div class="text-zinc-600 text-xl sm:text-2xl">→</div>
                           <div class="text-[9px] text-yellow-500">${plan.remain}F</div>
                       </div>
                       <div class="text-center min-w-[70px]">
                           ${finalDisplay}
                       </div>
                   </div>`;
            }

            // 投技显示"放倒"，普通招式显示 Hit/Block
            const hitColor = getFrameColorClass(plan.finalHit);
            const blockColor = getFrameColorClass(plan.finalBlock);
            const statsHtml = isThrow 
                ? `<span class="text-zinc-400 text-xs">放倒</span>`
                : `<span class="text-sm text-zinc-500">H</span><span class="text-lg font-bold ${hitColor} ml-1">${plan.finalHit >= 0 ? '+' : ''}${plan.finalHit}</span>
                   <span class="text-sm text-zinc-500 ml-3">B</span><span class="text-lg font-bold ${blockColor} ml-1">${plan.finalBlock >= 0 ? '+' : ''}${plan.finalBlock}</span>`;

            // 收藏星和最小化按钮
            const starIcon = isFavorite ? '★' : '☆';
            const starClass = isFavorite ? 'text-yellow-400' : 'text-zinc-400 hover:text-yellow-400';
            
            // 收藏印章
            const stampHtml = isFavorite ? '<div class="favorite-stamp">FAVE</div>' : '';
            
            // 方案标签（如"打投择"）
            const labelHtml = label ? `<div class="absolute top-1 left-1 sm:top-2 sm:left-2 text-[9px] font-bold px-1.5 py-0.5 bg-amber-600/80 text-white uppercase">${label}</div>` : '';

            // 生成复制文本
            const copyText = generatePlanCopyText(plan, adv, label);

            return `
                <div class="mb-3 p-4 border ${borderColor} ${bgColor} relative group overflow-visible recommend-card">
                    ${stampHtml}
                    ${labelHtml}
                    ${tooltipHtml}
                    <div class="absolute top-1 right-1 sm:top-2 sm:right-2 flex gap-1 opacity-80 group-hover:opacity-100 transition-opacity">
                        <button onclick="copyPlanInfo(\`${copyText}\`)" class="text-zinc-500 hover:text-cyan-400 text-base sm:text-sm p-2 sm:p-1 transition-colors opacity-70 hover:opacity-100" title="复制方案">📋</button>
                        <button onclick="toggleFavorite(${adv}, '${safePlanKey}')" class="${starClass} text-xl sm:text-lg p-2 sm:p-1 transition-colors" title="收藏">${starIcon}</button>
                        <button onclick="minimizePlan(${adv}, '${safePlanKey}')" class="text-zinc-400 hover:text-zinc-200 text-base sm:text-sm p-2 sm:p-1 transition-colors" title="折叠至备选">▼</button>
                    </div>
                    <div class="mb-2">
                        ${stepsHtml}
                    </div>
                    <div class="text-center border-t border-zinc-800/50 pt-2">
                        ${statsHtml}
                    </div>
                </div>
            `;
        }

        // 渲染备选方案（可展开详情，带最大化按钮）
        function renderAltPlan(plan, adv) {
            if (!plan) return '';
            
            const planKey = getPlanKey(plan);
            const safePlanKey = getSafePlanKey(plan);  // 用于嵌入HTML
            const isFavorite = isPlanFavorite(adv, planKey);
            
            let desc;
            if (plan.isDirect) {
                desc = `直接 ${plan.meatyMove.name}`;
            } else if (plan.killMove2) {
                const separator = plan.isCommutative ? '+' : '→';
                desc = `${plan.killMove.name} ${separator} ${plan.killMove2.name} → ${plan.meatyMove.name}`;
            } else {
                desc = `${plan.killMove.name} → ${plan.meatyMove.name}`;
            }
            
            // 生成展开后的详情
            let detailHtml = renderAltPlanDetail(plan, adv);
            
            // 收藏星样式
            const starIcon = isFavorite ? '★' : '☆';
            const starClass = isFavorite ? 'text-yellow-400' : 'text-zinc-400 hover:text-yellow-400';
            const rowBg = isFavorite ? 'bg-yellow-900/10' : '';

            const stolenColorAlt = getStolenColorClass(plan.stolen);
            
            // 生成复制文本
            const copyText = generatePlanCopyText(plan, adv, '');
            
            return `
                <details class="border-b border-zinc-800/50 ${rowBg}">
                    <summary class="flex items-center justify-between py-2 cursor-pointer hover:bg-zinc-800/30 transition-colors group">
                        <span class="text-sm text-zinc-400">${desc}</span>
                        <div class="flex gap-1 sm:gap-2 text-sm font-bold items-center">
                            <span class="${stolenColorAlt} text-xs sm:text-sm">偷${plan.stolen}F</span>
                            <span class="${getFrameColorClass(plan.finalHit)} text-xs sm:text-sm">H${plan.finalHit >= 0 ? '+' : ''}${plan.finalHit}</span>
                            <span class="${getFrameColorClass(plan.finalBlock)} text-xs sm:text-sm">B${plan.finalBlock >= 0 ? '+' : ''}${plan.finalBlock}</span>
                            <button onclick="event.stopPropagation(); copyPlanInfo(\`${copyText}\`)" class="text-zinc-500 hover:text-cyan-400 transition-colors p-1.5 sm:p-1 text-base sm:text-sm opacity-70 hover:opacity-100" title="复制方案">📋</button>
                            <button onclick="event.stopPropagation(); toggleFavorite(${adv}, '${safePlanKey}')" class="${starClass} transition-colors p-1.5 sm:p-1 text-base sm:text-sm" title="收藏">${starIcon}</button>
                            <button onclick="event.stopPropagation(); maximizePlan(${adv}, '${safePlanKey}')" class="text-zinc-400 hover:text-zinc-200 transition-colors p-1.5 sm:p-1 text-base sm:text-sm" title="置顶显示">▲</button>
                        </div>
                    </summary>
                    <div class="py-2 px-2 bg-zinc-800/20">
                        ${detailHtml}
                    </div>
                </details>
            `;
        }
        
        // 渲染备选方案展开详情
        function renderAltPlanDetail(plan, adv) {
            const isThrow = plan.isThrow;
            const stolenColorDetail = getStolenColorClass(plan.stolen);
            
            let stepsHtml;
            
            if (plan.isDirect) {
                stepsHtml = `<div class="text-center">
                       <div class="text-[10px] text-zinc-600 uppercase mb-2">直接${isThrow ? '投' : '压制'} (剩余 ${plan.remain}F)</div>
                       <div class="impact-text text-3xl sm:text-4xl font-black text-white leading-none">${plan.meatyMove.name}</div>
                       ${!isThrow ? `<div class="text-sm mt-2"><span class="text-zinc-500">偷</span><span class="${stolenColorDetail} font-bold">${plan.stolen}F</span></div>` : ''}
                   </div>`;
            } else if (plan.killMove2) {
                const remain1 = adv - plan.killTotal;
                const separator = plan.isCommutative ? '+' : '→';
                
                stepsHtml = `<div class="flex items-center justify-center gap-2 sm:gap-3 flex-wrap">
                       <div class="text-center min-w-[60px]">
                           <div class="text-[9px] text-zinc-600 uppercase mb-1">卡帧①</div>
                           <div class="impact-text text-xl sm:text-2xl font-black text-white leading-none">${plan.killMove.name}</div>
                           <div class="text-[10px] text-zinc-500 mt-1">-${plan.killTotal}F</div>
                       </div>
                       <div class="text-center">
                           <div class="text-zinc-600 text-lg">${separator}</div>
                           <div class="text-[9px] text-yellow-500">${remain1}F</div>
                       </div>
                       <div class="text-center min-w-[60px]">
                           <div class="text-[9px] text-zinc-600 uppercase mb-1">卡帧②</div>
                           <div class="impact-text text-xl sm:text-2xl font-black text-white leading-none">${plan.killMove2.name}</div>
                           <div class="text-[10px] text-zinc-500 mt-1">-${plan.killTotal2}F</div>
                       </div>
                       <div class="text-center">
                           <div class="text-zinc-600 text-lg">→</div>
                           <div class="text-[9px] text-yellow-500">${plan.remain}F</div>
                       </div>
                       <div class="text-center min-w-[60px]">
                           <div class="text-[9px] text-zinc-500 uppercase mb-1">${isThrow ? '投' : '压制'}</div>
                           <div class="impact-text text-xl sm:text-2xl font-black text-white leading-none">${plan.meatyMove.name}</div>
                           ${!isThrow ? `<div class="text-[10px] mt-1"><span class="text-zinc-500">偷</span><span class="${stolenColorDetail} font-bold">${plan.stolen}F</span></div>` : ''}
                       </div>
                   </div>`;
            } else {
                stepsHtml = `<div class="flex items-center justify-center gap-3 sm:gap-5">
                       <div class="text-center min-w-[70px]">
                           <div class="text-[9px] text-zinc-600 uppercase mb-1">卡帧</div>
                           <div class="impact-text text-2xl sm:text-3xl font-black text-white leading-none">${plan.killMove.name}</div>
                           <div class="text-xs text-zinc-500 mt-1">-${plan.killTotal}F</div>
                       </div>
                       <div class="text-center">
                           <div class="text-zinc-600 text-xl">→</div>
                           <div class="text-[10px] text-yellow-500">剩${plan.remain}F</div>
                       </div>
                       <div class="text-center min-w-[70px]">
                           <div class="text-[9px] text-zinc-500 uppercase mb-1">${isThrow ? '投' : '压制'}</div>
                           <div class="impact-text text-2xl sm:text-3xl font-black text-white leading-none">${plan.meatyMove.name}</div>
                           ${!isThrow ? `<div class="text-xs mt-1"><span class="text-zinc-500">偷</span><span class="${stolenColorDetail} font-bold">${plan.stolen}F</span></div>` : ''}
                       </div>
                   </div>`;
            }

            const statsHtml = isThrow 
                ? `<div class="text-center text-zinc-400 text-xs font-bold mt-3">
                       放倒
                   </div>`
                : `<div class="flex justify-center gap-6 mt-3">
                       <div class="text-center">
                           <span class="text-xs text-zinc-600 uppercase">Hit</span>
                           <span class="text-xl font-black ${getFrameColorClass(plan.finalHit)} ml-1">${plan.finalHit >= 0 ? '+' : ''}${plan.finalHit}</span>
                       </div>
                       <div class="text-center">
                           <span class="text-xs text-zinc-600 uppercase">Block</span>
                           <span class="text-xl font-black ${getFrameColorClass(plan.finalBlock)} ml-1">${plan.finalBlock >= 0 ? '+' : ''}${plan.finalBlock}</span>
                       </div>
                   </div>`;

            return `
                <div class="py-2">
                    ${stepsHtml}
                    ${statsHtml}
                </div>
            `;
        }
        
        // 渲染投技备选方案（可展开详情）
        function renderAltThrowPlan(plan, adv) {
            if (!plan) return '';
            
            const planKey = getPlanKey(plan);
            const safePlanKey = getSafePlanKey(plan);  // 用于嵌入HTML
            const isFavorite = isPlanFavorite(adv, planKey);
            
            let desc;
            if (plan.isDirect) {
                desc = `直接 ${plan.meatyMove.name}`;
            } else if (plan.killMove2) {
                const separator = plan.isCommutative ? '+' : '→';
                desc = `${plan.killMove.name} ${separator} ${plan.killMove2.name} → ${plan.meatyMove.name}`;
            } else {
                desc = `${plan.killMove.name} → ${plan.meatyMove.name}`;
            }
            
            let detailHtml = renderAltPlanDetail(plan, adv);
            
            const starIcon = isFavorite ? '★' : '☆';
            const starClass = isFavorite ? 'text-yellow-400' : 'text-zinc-400 hover:text-yellow-400';
            const rowBg = isFavorite ? 'bg-yellow-900/10' : '';

            return `
                <details class="border-b border-zinc-800/50 ${rowBg}">
                    <summary class="flex items-center justify-between py-2 cursor-pointer hover:bg-zinc-800/30 transition-colors">
                        <span class="text-sm text-zinc-400">${desc}</span>
                        <div class="flex gap-1 sm:gap-2 items-center">
                            <span class="text-[10px] sm:text-xs text-zinc-500">${plan.remain}F</span>
                            <button onclick="event.stopPropagation(); toggleFavorite(${adv}, '${safePlanKey}')" class="${starClass} transition-colors p-1.5 sm:p-1 text-base sm:text-sm" title="收藏">${starIcon}</button>
                            <button onclick="event.stopPropagation(); maximizePlan(${adv}, '${safePlanKey}')" class="text-zinc-400 hover:text-zinc-200 transition-colors p-1.5 sm:p-1 text-base sm:text-sm" title="置顶显示">▲</button>
                        </div>
                    </summary>
                    <div class="py-2 px-2 bg-zinc-800/20">
                        ${detailHtml}
                    </div>
                </details>
            `;
        }

        // 搜索过滤函数
        function filterSolutions() {
            renderNotes();
        }
        
        // 清除搜索
        function clearSearch() {
            const input = document.getElementById('solutionSearch');
            input.value = '';
            updateClearBtn();
            filterSolutions();
        }
        
        // 更新清除按钮显示状态
        function updateClearBtn() {
            const input = document.getElementById('solutionSearch');
            const btn = document.getElementById('clearSearchBtn');
            if (input.value.trim()) {
                btn.classList.remove('hidden');
            } else {
                btn.classList.add('hidden');
            }
        }
        
        // 切换排序方向
        function toggleSortOrder() {
            state.sortOrder = state.sortOrder === 'asc' ? 'desc' : 'asc';
            updateSortOrderUI();
            renderNotes();
        }
        
        // 更新排序按钮 UI
        function updateSortOrderUI() {
            const icon = document.getElementById('sortOrderIcon');
            const btn = document.getElementById('sortOrderBtn');
            if (state.sortOrder === 'asc') {
                icon.textContent = '↑';
                btn.title = '当前：从小到大，点击切换';
            } else {
                icon.textContent = '↓';
                btn.title = '当前：从大到小，点击切换';
            }
        }
        
        // 切换收藏状态
        function toggleFavorite(adv, planKey) {
            const char = state.currentCharacter;
            const template = getCurrentTemplate();
            
            // 如果不是"我的收藏"模板，首次修改时弹窗提示
            if (template.id !== 'my') {
                const warnKey = `${char}:${template.id}`;
                if (!state.templateModifyWarned[warnKey]) {
                    showTemplateModifyWarning(template.name, () => {
                        state.templateModifyWarned[warnKey] = true;
                        saveTemplateModifyWarned();
                        doToggleFavorite(adv, planKey);
                    });
                    return;
                }
            }
            
            doToggleFavorite(adv, planKey);
        }
        
        function doToggleFavorite(adv, planKey) {
            const template = getCurrentTemplate();
            const fullKey = `${planKey}|${adv}`;
            const favorites = template.favorites || [];
            
            const index = favorites.indexOf(fullKey);
            if (index > -1) {
                // 取消收藏
                favorites.splice(index, 1);
            } else {
                // 添加收藏
                favorites.push(fullKey);
            }
            
            template.favorites = favorites;
            saveFavoriteTemplates();
            
            // 如果在收藏视图，刷新收藏视图；否则刷新普通视图
            if (state.showOnlyFavorites) {
                renderFavoritesView();
            } else {
            renderNotes();
            }
        }
        
        // 最小化方案（移到备选列表）
        function minimizePlan(adv, planKey) {
            const stateKey = `${state.currentCharacter}:${adv}:${planKey}`;
            state.minimized[stateKey] = true;
            saveMinimized();
            renderNotes();
        }
        
        // 最大化方案（从备选移到主显示）
        function maximizePlan(adv, planKey) {
            const stateKey = `${state.currentCharacter}:${adv}:${planKey}`;
            delete state.minimized[stateKey];
            saveMinimized();
            renderNotes();
        }
        
        // 检查方案是否被最小化
        function isPlanMinimized(adv, planKey) {
            return state.minimized[`${state.currentCharacter}:${adv}:${planKey}`] === true;
        }
        
        // 检查方案是否被收藏
        function isPlanFavorite(adv, planKey) {
            const template = getCurrentTemplate();
            const fullKey = `${planKey}|${adv}`;
            return (template.favorites || []).includes(fullKey);
        }
        
        // ========== 打投择收藏相关函数 ==========
        // 生成打投择收藏的key
        function getMixupKey(adv, remain, killDesc) {
            return `${adv}|${remain}|${killDesc}`;
        }
        
        // 检查打投择方案是否被收藏
        function isMixupFavorite(adv, remain, killDesc) {
            const template = getCurrentTemplate();
            const key = getMixupKey(adv, remain, killDesc);
            return (template.mixupFavorites || []).includes(key);
        }
        
        // 检查某个adv是否有任何打投择收藏
        function hasMixupFavoriteForAdv(adv) {
            const template = getCurrentTemplate();
            const mixupFavs = template.mixupFavorites || [];
            const prefix = `${adv}|`;
            return mixupFavs.some(key => key.startsWith(prefix));
        }
        
        // 切换打投择收藏
        function toggleMixupFavorite(adv, remain, killDesc) {
            const char = state.currentCharacter;
            const template = getCurrentTemplate();
            
            // 如果不是"我的收藏"模板，首次修改时弹窗提示
            if (template.id !== 'my') {
                const warnKey = `${char}:${template.id}`;
                if (!state.templateModifyWarned[warnKey]) {
                    showTemplateModifyWarning(template.name, () => {
                        state.templateModifyWarned[warnKey] = true;
                        saveTemplateModifyWarned();
                        doToggleMixupFavorite(adv, remain, killDesc);
                    });
                    return;
                }
            }
            
            doToggleMixupFavorite(adv, remain, killDesc);
        }
        
        function doToggleMixupFavorite(adv, remain, killDesc) {
            const template = getCurrentTemplate();
            const key = getMixupKey(adv, remain, killDesc);
            const mixupFavorites = template.mixupFavorites || [];
            
            const index = mixupFavorites.indexOf(key);
            if (index > -1) {
                mixupFavorites.splice(index, 1);
            } else {
                mixupFavorites.push(key);
            }
            
            template.mixupFavorites = mixupFavorites;
            saveFavoriteTemplates();
            
            if (state.showOnlyFavorites) {
                renderFavoritesView();
            } else {
                renderThrowMixupContent();
            }
        }
        
        // 检查打投择方案是否被隐藏
        function isMixupHidden(adv, remain, killDesc) {
            return state.mixupHidden[getMixupKey(adv, remain, killDesc)] === true;
        }
        
        // 切换打投择方案隐藏
        function toggleMixupHidden(adv, remain, killDesc) {
            const key = getMixupKey(adv, remain, killDesc);
            if (state.mixupHidden[key]) {
                delete state.mixupHidden[key];
            } else {
                state.mixupHidden[key] = true;
            }
            saveMixupHidden();
            renderThrowMixupContent();
        }
        
        // 保存/加载打投择收藏
        function saveMixupFavorites() {
            localStorage.setItem('sf6_mixup_favorites', JSON.stringify(state.mixupFavorites));
        }
        function loadMixupFavorites() {
            try {
                const saved = localStorage.getItem('sf6_mixup_favorites');
                return saved ? JSON.parse(saved) : {};
            } catch(e) { return {}; }
        }
        
        // 保存/加载打投择隐藏
        function saveMixupHidden() {
            localStorage.setItem('sf6_mixup_hidden', JSON.stringify(state.mixupHidden));
        }
        function loadMixupHidden() {
            try {
                const saved = localStorage.getItem('sf6_mixup_hidden');
                return saved ? JSON.parse(saved) : {};
            } catch(e) { return {}; }
        }
        
        // ==================== 收藏模板系统 ====================
        
        // 保存收藏模板
        function saveFavoriteTemplates() {
            try {
                localStorage.setItem(getGlobalStorageKey('favoriteTemplates'), JSON.stringify(state.favoriteTemplates));
            } catch (e) {
                console.warn('保存收藏模板失败:', e);
            }
        }
        
        // 加载收藏模板
        function loadFavoriteTemplates() {
            try {
                const saved = localStorage.getItem(getGlobalStorageKey('favoriteTemplates'));
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                return {};
            }
        }
        
        // 保存模板修改警告状态
        function saveTemplateModifyWarned() {
            try {
                localStorage.setItem(getGlobalStorageKey('templateModifyWarned'), JSON.stringify(state.templateModifyWarned));
            } catch (e) {
                console.warn('保存模板修改警告状态失败:', e);
            }
        }
        
        // 加载模板修改警告状态
        function loadTemplateModifyWarned() {
            try {
                const saved = localStorage.getItem(getGlobalStorageKey('templateModifyWarned'));
                return saved ? JSON.parse(saved) : {};
            } catch (e) {
                return {};
            }
        }
        
        // 初始化角色的模板结构
        function initCharacterTemplates(char) {
            if (!state.favoriteTemplates[char]) {
                state.favoriteTemplates[char] = {
                    current: 'my',
                    templates: {
                        'my': {
                            id: 'my',
                            name: '我的收藏',
                            type: 'user',
                            favorites: [],
                            mixupFavorites: []
                        }
                    }
                };
            }
            
            // 确保有 current 字段
            if (!state.favoriteTemplates[char].current) {
                state.favoriteTemplates[char].current = 'my';
            }
            
            // 确保有 templates 字段
            if (!state.favoriteTemplates[char].templates) {
                state.favoriteTemplates[char].templates = {};
            }
            
            // 确保有"我的收藏"模板
            if (!state.favoriteTemplates[char].templates['my']) {
                state.favoriteTemplates[char].templates['my'] = {
                    id: 'my',
                    name: '我的收藏',
                    type: 'user',
                    favorites: [],
                    mixupFavorites: []
                };
            }
        }
        
        // 从旧格式迁移收藏数据
        function migrateLegacyFavorites() {
            // 遍历所有旧的收藏数据
            const charPrefix = {};
            Object.keys(state.favorites).forEach(key => {
                if (state.favorites[key]) {
                    // key 格式: "charName:adv:planKey"
                    const parts = key.split(':');
                    if (parts.length >= 3) {
                        const char = parts[0];
                        const adv = parts[1];
                        const planKey = parts.slice(2).join(':');
                        
                        if (!charPrefix[char]) charPrefix[char] = [];
                        charPrefix[char].push(`${planKey}|${adv}`);
                    }
                }
            });
            
            // 迁移打投择收藏
            const charMixup = {};
            Object.keys(state.mixupFavorites).forEach(key => {
                if (state.mixupFavorites[key]) {
                    // key 格式: "charName:adv:remain:killDesc"
                    const parts = key.split(':');
                    if (parts.length >= 3) {
                        const char = parts[0];
                        const adv = parts[1];
                        const remain = parts[2];
                        const killDesc = parts.slice(3).join(':');
                        
                        if (!charMixup[char]) charMixup[char] = [];
                        charMixup[char].push(`${adv}|${remain}|${killDesc}`);
                    }
                }
            });
            
            // 写入新格式
            Object.keys(charPrefix).forEach(char => {
                initCharacterTemplates(char);
                state.favoriteTemplates[char].templates['my'].favorites = charPrefix[char];
            });
            
            Object.keys(charMixup).forEach(char => {
                initCharacterTemplates(char);
                state.favoriteTemplates[char].templates['my'].mixupFavorites = charMixup[char];
            });
            
            console.log('[迁移] 已从旧格式迁移收藏数据');
        }
        
        // 获取当前角色当前模板
        function getCurrentTemplate() {
            const char = state.currentCharacter;
            initCharacterTemplates(char);
            const templateId = state.favoriteTemplates[char].current;
            return state.favoriteTemplates[char].templates[templateId];
        }
        
        // 获取当前角色所有模板列表
        function getAllTemplates() {
            const char = state.currentCharacter;
            initCharacterTemplates(char);
            return state.favoriteTemplates[char].templates;
        }
        
        // 获取默认模板名称
        function getDefaultTemplateName(char) {
            const templates = state.favoriteTemplates[char]?.templates || {};
            const existingNames = Object.values(templates).map(t => t.name);
            
            let counter = 2;
            while (existingNames.includes(`我的收藏${counter}`)) {
                counter++;
            }
            return `我的收藏${counter}`;
        }
        
        // 验证模板名称
        function validateTemplateName(char, name, excludeId) {
            if (!name || name.trim() === '') {
                return { valid: false, error: "模板名称不能为空" };
            }
            if (name.length > 10) {
                return { valid: false, error: "模板名称不超过10个字符" };
            }
            
            const templates = state.favoriteTemplates[char]?.templates || {};
            const existingNames = Object.entries(templates)
                .filter(([id, t]) => id !== excludeId)
                .map(([id, t]) => t.name);
                
            if (existingNames.includes(name.trim())) {
                return { valid: false, error: "模板名称已存在" };
            }
            
            return { valid: true };
        }
        
        // 切换模板
        function switchTemplate(templateId) {
            const char = state.currentCharacter;
            initCharacterTemplates(char);
            
            if (state.favoriteTemplates[char].templates[templateId]) {
                state.favoriteTemplates[char].current = templateId;
                saveFavoriteTemplates();
                renderFavoritesView();
                updateTemplateSelector();
            }
        }
        
        // 导入模板
        function importTemplate(data, templateName) {
            const char = data.character || state.currentCharacter;
            
            // 如果角色不匹配，需要切换角色
            if (char !== state.currentCharacter) {
                selectCharacter(char);
            }
            
            initCharacterTemplates(char);
            
            // 生成新模板 ID
            const templateId = `imported_${Date.now()}`;
            
            // 创建新模板
            state.favoriteTemplates[char].templates[templateId] = {
                id: templateId,
                name: templateName,
                type: 'imported',
                favorites: data.favorites || [],
                mixupFavorites: data.mixupFavorites || []
            };
            
            // 切换到新模板
            state.favoriteTemplates[char].current = templateId;
            
            saveFavoriteTemplates();
            return templateId;
        }
        
        // 删除模板
        function deleteTemplate(templateId) {
            const char = state.currentCharacter;
            const template = state.favoriteTemplates[char]?.templates[templateId];
            
            // 不能删除"我的收藏"
            if (templateId === 'my' || !template) {
                return false;
            }
            
            // 删除模板
            delete state.favoriteTemplates[char].templates[templateId];
            
            // 如果删除的是当前模板，切换到"我的收藏"
            if (state.favoriteTemplates[char].current === templateId) {
                state.favoriteTemplates[char].current = 'my';
            }
            
            saveFavoriteTemplates();
            return true;
        }
        
        // 导出模板
        function exportCurrentTemplate() {
            const template = getCurrentTemplate();
            const char = state.currentCharacter;
            
            const exportData = {
                name: template.name,
                character: char,
                timestamp: new Date().toISOString(),
                favorites: template.favorites || [],
                mixupFavorites: template.mixupFavorites || []
            };
            
            return JSON.stringify(exportData, null, 2);
        }
        
        // 切换有利帧展开/收起（支持多项同时展开）
        function toggleAdvExpand(adv) {
            if (state.expandedAdvSet.has(adv)) {
                state.expandedAdvSet.delete(adv);  // 收起
                // 如果有收起的，更新全局状态
                if (state.allDetailsExpanded) {
                    state.allDetailsExpanded = false;
                    updateToggleAllBtn();
                }
            } else {
                state.expandedAdvSet.add(adv);   // 展开
            }
            renderNotes();
        }
        
        // 切换全部展开/收起
        function toggleAllDetails() {
            state.allDetailsExpanded = !state.allDetailsExpanded;
            if (state.allDetailsExpanded) {
                // 收集当前所有可见的场景adv
                const searchInput = document.getElementById('solutionSearch');
                const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
                
                state.notes.forEach((note, idx) => {
                    if (note.isFuzzy && note.advRange) {
                        const fuzzyKey = `fuzzy_${idx}`;
                        // 检查是否符合搜索条件
                        if (!searchTerm || matchesFuzzySearch(note, searchTerm)) {
                            state.expandedAdvSet.add(fuzzyKey);
                        }
                    } else {
                        // 检查是否符合搜索条件
                        if (!searchTerm || matchesExactSearch(note, searchTerm)) {
                            state.expandedAdvSet.add(note.adv);
                        }
                    }
                });
            } else {
                state.expandedAdvSet.clear();
            }
            updateToggleAllBtn();
            renderNotes();
        }
        
        // 检查模糊场景是否匹配搜索
        function matchesFuzzySearch(note, searchTerm) {
            const advStr = `${note.advRange[0]}-${note.advRange[1]}`;
            return advStr.includes(searchTerm) || 
                   (note.context && note.context.toLowerCase().includes(searchTerm));
        }
        
        // 检查精确场景是否匹配搜索
        function matchesExactSearch(note, searchTerm) {
            const advStr = String(note.adv);
            return advStr.includes(searchTerm) || 
                   (note.context && note.context.toLowerCase().includes(searchTerm));
        }
        
        // 更新全局展开按钮状态
        function updateToggleAllBtn() {
            const btn = document.getElementById('toggleAllDetailsBtn');
            const icon = document.getElementById('toggleAllIcon');
            const text = document.getElementById('toggleAllText');
            if (btn && icon && text) {
                if (state.allDetailsExpanded) {
                    icon.textContent = '▲';
                    text.textContent = '收起';
                    btn.title = '收起所有详情';
                } else {
                    icon.textContent = '▼';
                    text.textContent = '展开';
                    btn.title = '展开所有详情';
                }
            }
        }
        
        // 切换收藏视图
        function toggleShowOnlyFavorites() {
            state.showOnlyFavorites = !state.showOnlyFavorites;
            updateShowFavoritesBtn();
            
            // 切换视图显示
            const normalView = document.getElementById('noteListContainer');
            const favView = document.getElementById('favoritesGridView');
            
            // 获取所有需要隐藏的正常视图元素
            const viewNotes = document.getElementById('view-notes');
            const elementsToToggle = viewNotes ? Array.from(viewNotes.children).filter(el => 
                el.id !== 'noteListContainer' && el.id !== 'favoritesGridView'
            ) : [];
            
            if (state.showOnlyFavorites) {
                // 隐藏正常列表，显示收藏视图
                normalView.classList.add('hidden');
                elementsToToggle.forEach(el => el.classList.add('hidden'));
                favView.classList.remove('hidden');
                renderFavoritesView();
            } else {
                // 显示正常列表，隐藏收藏视图
                normalView.classList.remove('hidden');
                elementsToToggle.forEach(el => el.classList.remove('hidden'));
                favView.classList.add('hidden');
                renderNotes();
            }
        }
        
        // 更新收藏筛选按钮状态
        function updateShowFavoritesBtn() {
            const btn = document.getElementById('showFavoritesBtn');
            const icon = document.getElementById('showFavoritesIcon');
            if (btn && icon) {
                if (state.showOnlyFavorites) {
                    icon.textContent = '★';
                    btn.classList.add('active');
                    btn.title = '当前：收藏视图，点击返回列表';
                    btn.style.background = 'color-mix(in srgb, var(--theme-primary) 30%, transparent)';
                    btn.style.borderColor = 'var(--theme-primary)';
                    icon.style.color = '#facc15';
                } else {
                    icon.textContent = '☆';
                    btn.classList.remove('active');
                    btn.title = '查看收藏方案';
                    btn.style.background = '';
                    btn.style.borderColor = '';
                    icon.style.color = '';
                }
            }
        }
        
        // 渲染收藏卡片视图
        function renderFavoritesView() {
            const meatyGrid = document.getElementById('favMeatyGrid');
            const mixupGrid = document.getElementById('favMixupGrid');
            const meatySection = document.getElementById('favMeatySection');
            const mixupSection = document.getElementById('favMixupSection');
            const emptyState = document.getElementById('favEmptyState');
            const countSpan = document.getElementById('favoritesCount');
            
            // 更新模板选择器
            updateTemplateSelector();
            
            // 从当前模板获取收藏
            const template = getCurrentTemplate();
            const favorites = template.favorites || [];
            const mixupFavorites = template.mixupFavorites || [];
            
            // 收集所有收藏的压制方案
            const meatyFavs = [];
            favorites.forEach(fullKey => {
                // fullKey 格式: "planKey|adv"
                const lastPipe = fullKey.lastIndexOf('|');
                if (lastPipe === -1) return;
                
                const planKey = fullKey.substring(0, lastPipe);
                const adv = parseInt(fullKey.substring(lastPipe + 1));
                
                if (isNaN(adv)) return;
                
                // 获取该 adv 对应的场景
                const contexts = [];
                state.notes.forEach(note => {
                    if (note.adv === adv && !note.isFuzzy) {
                        contexts.push(note.context);
                    }
                });
                
                meatyFavs.push({ adv, planKey, contexts });
            });
            
            // 收集所有收藏的打投择方案
            const mixupFavs = [];
            mixupFavorites.forEach(key => {
                // key 格式: "adv|remain|killDesc"
                const parts = key.split('|');
                if (parts.length >= 3) {
                    const adv = parseInt(parts[0]);
                    const remain = parseInt(parts[1]);
                    const killDesc = parts.slice(2).join('|');
                    
                    // 获取该 adv 对应的场景
                    const contexts = [];
                    state.notes.forEach(note => {
                        if (note.adv === adv && !note.isFuzzy) {
                            contexts.push(note.context);
                        }
                    });
                    
                    mixupFavs.push({ adv, remain, killDesc, contexts });
                }
            });
            
            const totalCount = meatyFavs.length + mixupFavs.length;
            countSpan.textContent = `(${totalCount})`;
            
            // 空状态
            if (totalCount === 0) {
                meatySection.classList.add('hidden');
                mixupSection.classList.add('hidden');
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            // 渲染压制方案卡片
            if (meatyFavs.length > 0) {
                meatySection.classList.remove('hidden');
                meatyGrid.innerHTML = meatyFavs.map(fav => {
                    const contextsHtml = fav.contexts.length > 0 
                        ? fav.contexts.map(ctx => `<span class="fav-card-context">${escapeHtml(ctx)}</span>`).join('')
                        : '<span class="fav-card-context" style="background: #555; color: #999;">无场景</span>';
                    
                    // 解析方案描述：planKey 格式为 "kill1|kill2|meaty"
                    // DIRECT||meaty -> 直接压制
                    // kill1||meaty -> 一步卡帧
                    // kill1|kill2|meaty -> 两步卡帧
                    let planDisplay = '';
                    const parts = fav.planKey.split('|');
                    const kill1 = parts[0] || '';
                    const kill2 = parts[1] || '';
                    const meaty = parts[2] || parts[1] || '';  // 兼容两种格式
                    
                    if (kill1 === 'DIRECT') {
                        // 直接压制：只显示招式名
                        planDisplay = escapeHtml(meaty);
                    } else if (kill2 && kill2 !== '') {
                        // 两步卡帧（kill2 不为空）
                        planDisplay = `${escapeHtml(kill1)} <span class="fav-card-plan-arrow">+</span> ${escapeHtml(kill2)} <span class="fav-card-plan-arrow">→</span> ${escapeHtml(meaty)}`;
                    } else {
                        // 一步卡帧（kill2 为空）
                        const actualMeaty = parts[2] || parts[1] || '';
                        planDisplay = `${escapeHtml(kill1)} <span class="fav-card-plan-arrow">→</span> ${escapeHtml(actualMeaty)}`;
                    }
                    
                    const safePlanKey = encodeURIComponent(fav.planKey);
                    
                    return `
                        <div class="fav-card" id="fav-meaty-${fav.adv}-${safePlanKey}">
                            <div class="fav-card-plan">${planDisplay}</div>
                            <div class="fav-card-contexts">${contextsHtml}</div>
                            <div class="fav-card-header">
                                <span class="fav-card-adv">+${fav.adv}F</span>
                                <span class="fav-card-star" onclick="removeFavoriteMeaty(${fav.adv}, '${safePlanKey}')" title="取消收藏">★</span>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                meatySection.classList.add('hidden');
            }
            
            // 渲染打投择方案卡片
            if (mixupFavs.length > 0) {
                mixupSection.classList.remove('hidden');
                mixupGrid.innerHTML = mixupFavs.map(fav => {
                    const contextsHtml = fav.contexts.length > 0 
                        ? fav.contexts.map(ctx => `<span class="fav-card-context">${escapeHtml(ctx)}</span>`).join('')
                        : '<span class="fav-card-context" style="background: #555; color: #999;">无场景</span>';
                    
                    // 解析卡帧描述
                    let planDisplay = fav.killDesc;
                    if (fav.killDesc.includes(' + ')) {
                        const parts = fav.killDesc.split(' + ');
                        planDisplay = parts.join(' <span class="fav-card-plan-arrow">+</span> ');
                    } else if (fav.killDesc.includes(' → ')) {
                        const parts = fav.killDesc.split(' → ');
                        planDisplay = parts.join(' <span class="fav-card-plan-arrow">→</span> ');
                    }
                    
                    const safeKillDesc = encodeURIComponent(fav.killDesc);
                    
                    return `
                        <div class="fav-card" id="fav-mixup-${fav.adv}-${fav.remain}-${safeKillDesc}">
                            <div class="fav-card-header">
                                <span class="fav-card-adv">+${fav.adv}F</span>
                                <span class="fav-card-star" onclick="removeFavoriteMixup(${fav.adv}, ${fav.remain}, '${safeKillDesc}')" title="取消收藏">★</span>
                            </div>
                            <div class="fav-card-contexts">${contextsHtml}</div>
                            <div class="fav-card-plan">${planDisplay}</div>
                            <div class="text-center">
                                <span class="fav-card-mixup-tag">${fav.remain}F 打投择</span>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                mixupSection.classList.add('hidden');
            }
        }
        
        // 从收藏视图中移除压制方案
        function removeFavoriteMeaty(adv, encodedPlanKey) {
            const planKey = decodeURIComponent(encodedPlanKey);
            
            // 添加移除动画
            const cardId = `fav-meaty-${adv}-${encodedPlanKey}`;
            const card = document.getElementById(cardId);
            if (card) {
                card.classList.add('removing');
                setTimeout(() => {
                    doToggleFavorite(adv, planKey);
                }, 300);
            } else {
                doToggleFavorite(adv, planKey);
            }
        }
        
        // 从收藏视图中移除打投择方案
        function removeFavoriteMixup(adv, remain, encodedKillDesc) {
            const killDesc = decodeURIComponent(encodedKillDesc);
            
            // 添加移除动画
            const cardId = `fav-mixup-${adv}-${remain}-${encodedKillDesc}`;
            const card = document.getElementById(cardId);
            if (card) {
                card.classList.add('removing');
                setTimeout(() => {
                    doToggleMixupFavorite(adv, remain, killDesc);
                }, 300);
            } else {
                doToggleMixupFavorite(adv, remain, killDesc);
            }
        }
        
        // ========== 模糊场景渲染 ==========
        function renderFuzzyScenario(group, cardIndex) {
            const minAdv = group.advRange[0];
            const maxAdv = group.advRange[1];
            const result = calculateFuzzyBestPlans(minAdv, maxAdv);
            const note = state.notes[group.idx];
            const isPreset = !note.isUserAdded;
            const deleteTitle = isPreset ? "此为预设场景，删除后可通过重置恢复" : "删除此用户场景";
            
            // 模糊标签
            const fuzzyBadge = `<span class="fuzzy-badge" title="模糊帧数场景">🎲 模糊</span>`;
            
            // 判断是否展开
            const isExpanded = state.expandedAdvSet.has(`fuzzy_${group.idx}`);
            
            // ========== 紧凑列表视图 ==========
            if (!isExpanded) {
                let bestPlanDesc = '';
                if (result.bestByBlock) {
                    const plan = result.bestByBlock;
                    bestPlanDesc = plan.killDesc 
                        ? `${plan.killDesc} → ${plan.meatyMove.name}`
                        : `直接 ${plan.meatyMove.name}`;
                } else {
                    bestPlanDesc = '无符合条件的方案';
                }
                
                return `
                    <div class="trend-card py-3 px-4 cursor-pointer hover:bg-opacity-80 transition-all fuzzy-scenario-card" onclick="toggleAdvExpand('fuzzy_${group.idx}')" style="animation-delay: ${cardIndex * 0.02}s">
                        <div class="flex items-center gap-2 sm:gap-3">
                            <span class="impact-text text-xl sm:text-2xl font-black min-w-[80px] sm:min-w-[90px] flex-shrink-0" style="color: var(--theme-secondary);">${minAdv}~${maxAdv}F</span>
                            <span class="compact-context-tag">${escapeHtml(group.context)}</span>
                            ${fuzzyBadge}
                            <span class="text-zinc-600 mx-1 flex-shrink-0">→</span>
                            <span class="text-white font-bold compact-plan-desc flex-1 min-w-0">${bestPlanDesc}</span>
                            <span class="text-zinc-600 text-xs ml-2 flex-shrink-0">▼</span>
                        </div>
                    </div>
                `;
            }
            
            // ========== 展开的详细视图 ==========
            const leftPanel = `
                <div class="flex flex-col min-w-0 sm:min-w-[160px] items-start lg:border-r border-zinc-800 lg:pr-6 w-full lg:w-auto">
                    <div class="flex items-center gap-3 sm:block">
                        <div class="impact-text text-3xl sm:text-4xl md:text-5xl leading-none frame-number" style="color: var(--theme-secondary);">${minAdv}~${maxAdv}F</div>
                        <div class="sm:hidden">${fuzzyBadge}</div>
                    </div>
                    <div class="hidden sm:block mt-2">${fuzzyBadge}</div>
                    <div class="flex flex-wrap sm:flex-col gap-2 sm:gap-1 mt-2 sm:mt-3 w-full">
                        <div class="flex items-center gap-1 sm:gap-2 group/ctx">
                            <div class="expanded-context-tag text-xs sm:text-sm font-black uppercase tracking-wide px-2 py-1 border-l-2 flex-1 ${isPreset ? 'context-tag-preset' : 'context-tag'}">${escapeHtml(group.context)}</div>
                            <button onclick="event.stopPropagation(); removeNote(${group.idx})" class="text-zinc-600 hover:text-red-500 text-lg sm:text-base p-1.5 sm:p-1 opacity-70 sm:opacity-0 sm:group-hover/ctx:opacity-100 transition-all flex-shrink-0" title="${deleteTitle}">✕</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 无任何可用方案
            if (!result.bestByBlock && !result.bestByHit) {
                return `
                    <div class="trend-card fuzzy-scenario-card">
                        <div onclick="toggleAdvExpand('fuzzy_${group.idx}')" class="px-4 sm:px-5 py-3 cursor-pointer text-zinc-300 hover:text-white text-sm font-bold transition-colors select-none flex items-center gap-2 border-b" style="border-color: var(--theme-card-border);">
                            <span class="text-zinc-500 text-xs">▼</span>
                            收起 ${minAdv}~${maxAdv}F 详细方案
                        </div>
                        <div class="p-4 sm:p-6 flex flex-col lg:flex-row items-center gap-4 sm:gap-6">
                            ${leftPanel}
                            <div class="flex-1 text-zinc-600 font-bold italic">
                                未找到符合条件的压制方案<br>
                                <span class="text-xs text-zinc-700">约束: ①不被4帧抢 ②不挥空</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // 渲染方案列表
            let plansHtml = '';
            const allValidPlans = result.allPlans || [];
            
            if (allValidPlans.length <= 2) {
                // ≤2 个方案，直接显示全部
                plansHtml = allValidPlans.map((plan, i) => renderFuzzyPlanCard(plan, i === 0 ? '推荐' : '')).join('');
            } else {
                // >2 个方案，显示两个最优
                if (result.bestByBlock) {
                    plansHtml += renderFuzzyPlanCard(result.bestByBlock, '🛡️ 防御最优');
                }
                if (result.bestByHit && result.bestByHit.key !== result.bestByBlock?.key) {
                    plansHtml += renderFuzzyPlanCard(result.bestByHit, '⚔️ 命中最优');
                }
                plansHtml += `<div class="text-xs text-zinc-600 mt-2">共 ${allValidPlans.length} 个符合条件的方案</div>`;
            }
            
            return `
                <div class="trend-card fuzzy-scenario-card">
                    <div onclick="toggleAdvExpand('fuzzy_${group.idx}')" class="px-4 sm:px-5 py-3 cursor-pointer text-zinc-300 hover:text-white text-sm font-bold transition-colors select-none flex items-center gap-2 border-b" style="border-color: var(--theme-card-border);">
                        <span class="text-zinc-500 text-xs">▼</span>
                        收起 ${minAdv}~${maxAdv}F 详细方案
                    </div>
                    <div class="p-4 sm:p-6 flex flex-col lg:flex-row gap-4 sm:gap-6">
                        ${leftPanel}
                        <div class="flex-1 min-w-0">
                            <div class="space-y-3">
                                ${plansHtml}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 渲染单个模糊方案卡片
        function renderFuzzyPlanCard(plan, label) {
            const safetyMargin = plan.startup - plan.maxStolen;
            const planDesc = plan.killDesc 
                ? `<span class="text-zinc-400">${plan.killDesc}</span> → <span class="text-white font-bold">${plan.meatyMove.name}</span>`
                : `直接 <span class="text-white font-bold">${plan.meatyMove.name}</span>`;
            
            return `
                <div class="fuzzy-plan-card">
                    ${label ? `<div class="fuzzy-plan-label">${label}</div>` : ''}
                    <div class="fuzzy-plan-content">
                        <div class="fuzzy-plan-desc">${planDesc}</div>
                        <div class="fuzzy-plan-stats">
                            <span>平均 Block: <span class="${getFrameColorClass(plan.avgBlock)}">${plan.avgBlock >= 0 ? '+' : ''}${plan.avgBlock.toFixed(1)}F</span></span>
                            <span>平均 Hit: <span class="${getFrameColorClass(plan.avgHit)}">${plan.avgHit >= 0 ? '+' : ''}${plan.avgHit.toFixed(1)}F</span></span>
                        </div>
                        <div class="fuzzy-plan-detail">
                            偷帧: ${plan.minStolen}~${plan.maxStolen}F | 
                            安全余量: <span class="${safetyMargin >= 4 ? 'text-green-400' : 'text-red-400'}">${safetyMargin}F</span>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function renderNotes() {
            const container = document.getElementById('noteListContainer');
            const searchInput = document.getElementById('solutionSearch');
            const searchTerm = searchInput ? searchInput.value.trim().toLowerCase() : '';
            
            if (state.moveLibrary.length === 0) {
                container.innerHTML = `
                    <div class="trend-card p-8 text-center">
                        <div class="text-zinc-600 text-lg mb-2">📭 暂无 ${state.currentCharacter} 的帧数据</div>
                        <div class="text-zinc-700 text-sm">请前往 数据 页签导入数据</div>
                    </div>
                `;
                return;
            }

            // ========== 按 adv 分组，合并相同帧数的 context ==========
            // 精确场景分组
            const advGroups = {};
            // 模糊场景单独处理（不合并）
            const fuzzyGroups = [];
            
            state.notes.forEach((note, idx) => {
                if (note.isFuzzy && note.advRange) {
                    // 模糊场景
                    fuzzyGroups.push({
                        advRange: note.advRange,
                        context: note.context,
                        idx: idx,
                        isFuzzy: true
                    });
                } else {
                    // 精确场景
                    if (!advGroups[note.adv]) {
                        advGroups[note.adv] = { adv: note.adv, contexts: [], indices: [], isFuzzy: false };
                    }
                    advGroups[note.adv].contexts.push(note.context);
                    advGroups[note.adv].indices.push(idx);
                }
            });
            
            // 合并精确场景和模糊场景
            let allGroups = [
                ...Object.values(advGroups),
                ...fuzzyGroups
            ];
            
            // 按 adv 排序（模糊场景用范围的起始值排序）
            allGroups.sort((a, b) => {
                const advA = a.isFuzzy ? a.advRange[0] : a.adv;
                const advB = b.isFuzzy ? b.advRange[0] : b.adv;
                return state.sortOrder === 'asc' ? advA - advB : advB - advA;
            });
            
            // ========== 搜索过滤 ==========
            if (searchTerm) {
                allGroups = allGroups.filter(group => {
                    if (group.isFuzzy) {
                        // 模糊场景：匹配范围或 context
                        if (String(group.advRange[0]).includes(searchTerm) || 
                            String(group.advRange[1]).includes(searchTerm)) return true;
                        if (group.context.toLowerCase().includes(searchTerm)) return true;
                    } else {
                        // 精确场景：匹配帧数或 context
                        if (String(group.adv).includes(searchTerm)) return true;
                        if (group.contexts.some(ctx => ctx.toLowerCase().includes(searchTerm))) return true;
                    }
                    return false;
                });
            }
            
            // ========== 收藏筛选 ==========
            if (state.showOnlyFavorites) {
                allGroups = allGroups.filter(group => {
                    if (group.isFuzzy) {
                        // 模糊场景暂不支持收藏筛选
                        return false;
                    } else {
                        // 检查该场景是否有任何收藏的方案
                        const allPlans = calculateBestPlan(group.adv);
                        const hasFavoritePlan = allPlans.some(plan => 
                            isPlanFavorite(group.adv, getPlanKey(plan))
                        );
                        // 也检查打投择收藏
                        const hasFavoriteMixup = hasMixupFavoriteForAdv(group.adv);
                        return hasFavoritePlan || hasFavoriteMixup;
                    }
                });
            }
            
            let sortedGroups = allGroups;
            
            // 无匹配结果
            if (sortedGroups.length === 0) {
                // 区分无数据、收藏筛选无结果和搜索无结果
                const isEmptyNotes = state.notes.length === 0;
                let emptyHtml;
                
                if (isEmptyNotes) {
                    emptyHtml = `
                    <div class="trend-card p-8 text-center">
                        <div class="text-zinc-600 text-lg mb-2">📋 暂无 Scenario</div>
                        <div class="text-zinc-700 text-sm">点击 + 新增场景 添加有利帧情境</div>
                    </div>
                    `;
                } else if (state.showOnlyFavorites) {
                    emptyHtml = `
                        <div class="trend-card p-8 text-center">
                            <div class="text-zinc-600 text-lg mb-2">⭐ 暂无收藏方案</div>
                            <div class="text-zinc-700 text-sm">点击方案卡片的 ☆ 收藏喜欢的方案</div>
                            <button onclick="toggleShowOnlyFavorites()" class="mt-4 px-4 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-400 hover:text-white text-sm transition-colors">显示全部方案</button>
                        </div>
                    `;
                } else {
                    emptyHtml = `
                    <div class="trend-card p-8 text-center">
                        <div class="text-zinc-600 text-lg mb-2">🔍 未找到匹配的 Scenario</div>
                        <div class="text-zinc-700 text-sm">尝试其他搜索词，或清空搜索框查看全部</div>
                    </div>
                `;
                }
                
                container.innerHTML = emptyHtml;
                return;
            }

            container.innerHTML = sortedGroups.map((group, cardIndex) => {
                // ========== 模糊场景单独处理 ==========
                if (group.isFuzzy) {
                    return renderFuzzyScenario(group, cardIndex);
                }
                
                const allPlans = calculateBestPlan(group.adv);
                
                // 分离投技方案和普通方案
                const throwPlans = allPlans.filter(p => p.isThrow && p.remain >= 4 && p.remain <= 5);
                const normalPlans = allPlans.filter(p => !p.isThrow && p.finalBlock > 0);
                
                // 安全跳判断
                const safeJumpFramesForPanel = getSafeJumpFrames(state.currentCharacter);
                let safeJumpBadgeHtml = '';
                let safeJumpCompactHtml = '';
                
                if (group.adv === safeJumpFramesForPanel) {
                    safeJumpBadgeHtml = `<div class="safe-jump-badge mt-2" title="安全跳压制，防5帧及以上凹招">
                        <span class="safe-jump-badge-inner safe-jump-true">🦘 安全跳</span>
                    </div>`;
                    safeJumpCompactHtml = `<span class="safe-jump-badge-inner safe-jump-true text-[10px] ml-2">🦘 安全跳</span>`;
                } else if (group.adv === safeJumpFramesForPanel - 1) {
                    safeJumpBadgeHtml = `<div class="safe-jump-badge mt-2" title="伪安全跳压制，防6帧及以上凹招">
                        <span class="safe-jump-badge-inner safe-jump-pseudo">🦘 伪安全跳</span>
                    </div>`;
                    safeJumpCompactHtml = `<span class="safe-jump-badge-inner safe-jump-pseudo text-[10px] ml-2">🦘 伪安全跳</span>`;
                }
                
                // 判断是否展开
                const isExpanded = state.expandedAdvSet.has(group.adv);
                
                // ========== 紧凑列表视图 ==========
                if (!isExpanded) {
                    // 获取最佳方案的简要描述
                    let bestPlanDesc = '';
                    if (normalPlans.length > 0) {
                        const best = normalPlans[0];
                        if (best.isDirect) {
                            bestPlanDesc = `直接 ${best.meatyMove.name}`;
                        } else if (best.killMove) {
                            bestPlanDesc = best.killMove2 
                                ? `${best.killMove.name} → ${best.killMove2.name} → ${best.meatyMove.name}`
                                : `${best.killMove.name} → ${best.meatyMove.name}`;
                        }
                    } else if (throwPlans.length > 0) {
                        bestPlanDesc = '投技方案';
                    } else {
                        bestPlanDesc = '无有利方案';
                    }
                    
                    // 紧凑的 context 显示 - 桌面端显示2个，移动端显示1个
                    // 使用CSS media query控制，这里生成两套HTML
                    const firstContext = group.contexts[0] ? `<span class="compact-context-tag">${escapeHtml(group.contexts[0])}</span>` : '';
                    const secondContext = group.contexts[1] ? `<span class="compact-context-tag hidden sm:inline-block">${escapeHtml(group.contexts[1])}</span>` : '';
                    const moreCount = group.contexts.length - 1;
                    const moreContextsMobile = moreCount > 0 ? `<span class="text-xs text-zinc-400 ml-1 sm:hidden">+${moreCount}</span>` : '';
                    const moreContextsDesktop = group.contexts.length > 2 ? `<span class="text-xs text-zinc-400 ml-1 hidden sm:inline">+${group.contexts.length - 2}</span>` : '';
                    
                    return `
                        <div class="trend-card py-3 px-4 cursor-pointer hover:bg-opacity-80 transition-all" onclick="toggleAdvExpand(${group.adv})" style="animation-delay: ${cardIndex * 0.02}s">
                            <div class="flex items-center gap-2 sm:gap-3">
                                <span class="impact-text text-xl sm:text-2xl font-black min-w-[60px] sm:min-w-[70px] flex-shrink-0" style="color: var(--theme-secondary);">+${group.adv}F</span>
                                <div class="flex gap-1 items-center flex-shrink-0">
                                    ${firstContext}
                                    ${secondContext}
                                    ${moreContextsMobile}
                                    ${moreContextsDesktop}
                                </div>
                                ${safeJumpCompactHtml}
                                <span class="text-zinc-600 mx-1 flex-shrink-0">→</span>
                                <span class="text-white font-bold compact-plan-desc flex-1 min-w-0">${bestPlanDesc}</span>
                                <span class="text-zinc-600 text-xs ml-2 flex-shrink-0">▼</span>
                            </div>
                        </div>
                    `;
                }
                
                // ========== 展开的详细视图 ==========
                // 渲染左侧有利帧信息区
                const contextsHtml = group.indices.map((idx, i) => {
                    const ctx = group.contexts[i];
                    const note = state.notes[idx];
                    const isPreset = !note.isUserAdded;
                    const deleteTitle = isPreset ? "此为预设场景，删除后可通过重置恢复" : "删除此用户场景";
                    const contextClass = isPreset ? "context-tag-preset" : "context-tag";
                    return `<div class="flex items-center gap-1 sm:gap-2 group/ctx">
                        <div class="expanded-context-tag text-xs sm:text-sm font-black uppercase tracking-wide px-2 py-1 border-l-2 flex-1 ${contextClass}">${escapeHtml(ctx)}</div>
                        <button onclick="event.stopPropagation(); removeNote(${idx})" class="text-zinc-600 hover:text-red-500 text-lg sm:text-base p-1.5 sm:p-1 opacity-70 sm:opacity-0 sm:group-hover/ctx:opacity-100 transition-all flex-shrink-0" title="${deleteTitle}">✕</button>
                    </div>`;
                }).join('');
                
                const leftPanel = `
                    <div class="flex flex-col min-w-0 sm:min-w-[160px] items-start lg:border-r border-zinc-800 lg:pr-6 w-full lg:w-auto">
                        <div class="flex items-center gap-3 sm:block">
                            <div class="impact-text text-3xl sm:text-4xl md:text-5xl leading-none frame-number" style="color: var(--theme-secondary);">+${group.adv}F</div>
                            <div class="sm:hidden">${safeJumpBadgeHtml}</div>
                        </div>
                        <div class="hidden sm:block">${safeJumpBadgeHtml}</div>
                        <div class="flex flex-wrap sm:flex-col gap-2 sm:gap-1 mt-2 sm:mt-3 w-full">
                            ${contextsHtml}
                        </div>
                    </div>
                `;
                
                // 无任何可用方案
                if (normalPlans.length === 0 && throwPlans.length === 0) {
                    return `
                        <div class="trend-card">
                            <div onclick="toggleAdvExpand(${group.adv})" class="px-5 py-3 cursor-pointer text-zinc-300 hover:text-white text-sm font-bold transition-colors select-none flex items-center gap-2 border-b" style="border-color: var(--theme-card-border);">
                                <span class="text-zinc-500 text-xs">▼</span>
                                收起 +${group.adv}F 详细方案
                            </div>
                            <div class="p-6 flex flex-col lg:flex-row items-center gap-6">
                                ${leftPanel}
                                <div class="flex-1 text-zinc-600 font-bold italic">未找到有利压制方案</div>
                            </div>
                        </div>
                    `;
                }

                const mainKeys = new Set();  // 主显示区的方案
                const planReasons = new Map();  // 记录每个方案的推荐理由
                let mainHtml = '';
                
                // 检查方案是否被最小化
                const isMinimized = (plan) => isPlanMinimized(group.adv, getPlanKey(plan));
                
                // 过滤掉被最小化的方案
                const availableNormal = normalPlans.filter(p => !isMinimized(p));
                const availableThrow = throwPlans.filter(p => !isMinimized(p));
                
                // 添加方案到主显示区（自动去重，记录推荐理由）
                const addMainPlan = (plan, label = '', reason = '') => {
                    if (!plan) return false;
                    const key = getPlanKey(plan);
                    
                    // 如果已存在，追加理由
                    if (mainKeys.has(key)) {
                        if (reason && !planReasons.get(key).includes(reason)) {
                            planReasons.get(key).push(reason);
                        }
                        return false;
                    }
                    
                    mainKeys.add(key);
                    planReasons.set(key, reason ? [reason] : []);
                    return true;
                };
                
                // ========== 检查是否有收藏方案（新逻辑）==========
                // 如果当前场景有收藏方案，则推荐区只显示收藏方案
                const favoritePlans = allPlans.filter(plan => 
                    !isMinimized(plan) && 
                    isPlanFavorite(group.adv, getPlanKey(plan))
                );
                
                const hasFavorites = favoritePlans.length > 0;

                // ========== 如果有收藏方案，只显示收藏方案 ==========
                if (hasFavorites) {
                    // 只显示收藏方案
                    favoritePlans.forEach(plan => {
                        const isSafeJump = !plan.isDirect && plan.remain === getSafeJumpFrames(state.currentCharacter);
                        const isPseudoSafeJump = !plan.isDirect && plan.remain === getSafeJumpFrames(state.currentCharacter) - 1;
                        let label = '';
                        if (isSafeJump) label = '安全跳';
                        else if (isPseudoSafeJump) label = '伪安全跳';
                        addMainPlan(plan, label, 'favorite');
                    });
                } else {
                    // ========== 没有收藏时，使用默认推荐逻辑 ==========

                // ========== 0. 卡帧达成安全跳的方案 ==========
                // 注意：场景级别的安全跳判断已在 leftPanel 处理
                // 这里只处理通过卡帧达到安全跳帧数的方案
                const safeJumpFrames = getSafeJumpFrames(state.currentCharacter);
                
                // 找卡帧后能达到安全跳的方案（排除直接压制，因为那是场景级别的安全跳）
                const safeJumpPlans = availableNormal.filter(p => !p.isDirect && p.remain === safeJumpFrames);
                if (safeJumpPlans.length > 0) {
                    const bestSafeJump = [...safeJumpPlans].sort((a, b) => {
                        if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                        return b.finalHit - a.finalHit;
                    })[0];
                    addMainPlan(bestSafeJump, '安全跳', 'safe_jump');
                }
                
                // 如果没有安全跳方案，找伪安全跳方案
                if (safeJumpPlans.length === 0) {
                    const pseudoSafeJumpPlans = availableNormal.filter(p => !p.isDirect && p.remain === safeJumpFrames - 1);
                    if (pseudoSafeJumpPlans.length > 0) {
                        const bestPseudoSafeJump = [...pseudoSafeJumpPlans].sort((a, b) => {
                            if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                            return b.finalHit - a.finalHit;
                        })[0];
                        addMainPlan(bestPseudoSafeJump, '伪安全跳', 'pseudo_safe_jump');
                    }
                }

                // ========== 1. finalBlock 最高的方案 ==========
                if (availableNormal.length > 0) {
                    const bestBlockPlan = [...availableNormal].sort((a, b) => {
                        if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                        return b.finalHit - a.finalHit;
                    })[0];
                    addMainPlan(bestBlockPlan, '', 'best_block');
                }

                // ========== 2. finalHit 最高的方案 ==========
                if (availableNormal.length > 0) {
                    const bestHitPlan = [...availableNormal].sort((a, b) => {
                        if (b.finalHit !== a.finalHit) return b.finalHit - a.finalHit;
                        return b.finalBlock - a.finalBlock;
                    })[0];
                    addMainPlan(bestHitPlan, '', 'best_hit');
                }

                // ========== 3. 中/弱攻击中 finalBlock 最优 ==========
                const nonHeavyPlans = availableNormal.filter(p => {
                    const strength = getPlanStrength(p);
                    return strength === 'medium' || strength === 'light' || strength === 'other';
                });
                if (nonHeavyPlans.length > 0) {
                    const bestNonHeavyBlock = [...nonHeavyPlans].sort((a, b) => {
                        if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                        return b.finalHit - a.finalHit;
                    })[0];
                    addMainPlan(bestNonHeavyBlock, '', 'best_nonheavy_block');
                }

                // ========== 4. 中/弱攻击中 finalHit 最优 ==========
                if (nonHeavyPlans.length > 0) {
                    const bestNonHeavyHit = [...nonHeavyPlans].sort((a, b) => {
                        if (b.finalHit !== a.finalHit) return b.finalHit - a.finalHit;
                        return b.finalBlock - a.finalBlock;
                    })[0];
                    addMainPlan(bestNonHeavyHit, '', 'best_nonheavy_hit');
                }

                // ========== 5. 偷帧最多的方案 ==========
                if (availableNormal.length > 0) {
                    const bestStolenPlan = [...availableNormal].sort((a, b) => {
                        if (b.stolen !== a.stolen) return b.stolen - a.stolen;
                        if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                        return b.finalHit - a.finalHit;
                    })[0];
                    addMainPlan(bestStolenPlan, '', 'most_stolen');
                }

                // ========== 6. 投技方案 ==========
                let hasShownThrow = false;
                if (availableThrow.length > 0) {
                        // 投技方案按直接优先，然后按 remain 越小越优先
                    const sortedThrow = [...availableThrow].sort((a, b) => {
                        if (b.isDirect !== a.isDirect) return (b.isDirect ? 1 : 0) - (a.isDirect ? 1 : 0);
                        return a.remain - b.remain;
                    });
                    
                    const bestThrow = sortedThrow[0];
                    if (addMainPlan(bestThrow, '', 'throw')) {
                        hasShownThrow = true;
                    }
                }

                // ========== 6'. 零帧打投择方案：当没有正收益的普通方案在主显示区，但有投技时，显示 Block=0 的方案形成打投择 ==========
                const hasNormalMainPlan = normalPlans.some(p => mainKeys.has(getPlanKey(p)));
                if (!hasNormalMainPlan && hasShownThrow) {
                    // 从 allPlans 中找出所有 finalBlock === 0 的非投技方案且未被最小化的
                    const zeroBlockPlans = allPlans.filter(p => !p.isThrow && p.finalBlock === 0 && !isMinimized(p));
                    if (zeroBlockPlans.length > 0) {
                        // 按攻击等级排序：重 > 中 > 轻
                        const strengthOrder = { heavy: 0, medium: 1, light: 2, other: 3 };
                        const sortedZeroPlans = [...zeroBlockPlans].sort((a, b) => {
                            const aStrength = strengthOrder[getPlanStrength(a)] ?? 3;
                            const bStrength = strengthOrder[getPlanStrength(b)] ?? 3;
                            if (aStrength !== bStrength) return aStrength - bStrength;
                            // 同等级按 finalHit 排序
                            return b.finalHit - a.finalHit;
                        });
                        
                        // 显示所有 0 帧方案（打投择配合）
                        sortedZeroPlans.forEach(plan => {
                            addMainPlan(plan, '打投择', 'mixup');
                        });
                    }
                }
                
                // 获取当前角色的所有规则
                const rules = getAllRulesForCharacter(state.currentCharacter);
                
                // ========== 7. 用户倾向压制规则 ==========
                // 查找使用了倾向招式的方案，从备选提升到推荐
                const preferRules = rules.filter(r => r.type === 'prefer');
                preferRules.forEach(rule => {
                    const preferMoveName = rule.moveName.toUpperCase();
                    // 在备选中查找使用该招式作为压制的方案（满足偷帧≥1且finalBlock≥1）
                    const preferPlans = normalPlans.filter(p => 
                        !mainKeys.has(getPlanKey(p)) &&
                        !isMinimized(p) &&
                        p.meatyMove && 
                        p.meatyMove.name.toUpperCase() === preferMoveName &&
                        p.stolen >= 1 &&
                        p.finalBlock >= 1
                    );
                    
                    // 如果找到，添加最优的几个
                    if (preferPlans.length > 0) {
                        const sorted = [...preferPlans].sort((a, b) => {
                            if (b.finalBlock !== a.finalBlock) return b.finalBlock - a.finalBlock;
                            return b.finalHit - a.finalHit;
                        });
                        // 最多添加前2个最优方案
                        sorted.slice(0, 2).forEach(plan => {
                            addMainPlan(plan, '', `prefer:${rule.moveName}`);
                        });
                    }
                });
                }
                
                // ========== 最终渲染：按记录的理由渲染所有方案 ==========
                mainHtml = '';
                mainKeys.forEach(key => {
                    // 从 allPlans 中找回方案对象
                    const plan = allPlans.find(p => getPlanKey(p) === key);
                    if (plan) {
                        const reasons = planReasons.get(key) || [];
                        // 确定标签优先级：安全跳 > 伪安全跳 > 打投择
                        let label = '';
                        if (reasons.includes('safe_jump')) {
                            label = '安全跳';
                        } else if (reasons.includes('pseudo_safe_jump')) {
                            label = '伪安全跳';
                        } else if (reasons.includes('mixup')) {
                            label = '打投择';
                        }
                        mainHtml += renderMainPlan(plan, label, group.adv, reasons);
                    }
                });

                // ========== 4. 备选方案折叠区 ==========
                // 备选方案 = 不在主显示区的所有方案（包括被最小化的）
                // 筛选条件：偷帧≥1 且 finalBlock≥1
                const altNormalPlans = normalPlans.filter(p => 
                    !mainKeys.has(getPlanKey(p)) && 
                    p.stolen >= 1 && 
                    p.finalBlock >= 1
                );
                const altThrowPlans = throwPlans.filter(p => !mainKeys.has(getPlanKey(p)));
                
                let altHtml = '';
                
                // 普通备选方案
                if (altNormalPlans.length > 0) {
                    const altContent = altNormalPlans.map(plan => renderAltPlan(plan, group.adv)).join('');
                    altHtml += `
                        <details class="mt-2">
                            <summary class="text-[11px] text-zinc-600 cursor-pointer hover:text-zinc-400 transition-colors py-2 flex items-center gap-1">
                                <span class="collapse-arrow transition-transform duration-200">▶</span> ${altNormalPlans.length} 个备选打击方案 (Block > 0)
                            </summary>
                            <div class="mt-2 bg-zinc-900/50 p-3 border border-zinc-800">
                                ${altContent}
                            </div>
                        </details>
                    `;
                }
                
                // 投技备选方案
                if (altThrowPlans.length > 0) {
                    const altThrowContent = altThrowPlans.map(plan => renderAltThrowPlan(plan, group.adv)).join('');
                    
                    altHtml += `
                        <details class="mt-2">
                            <summary class="text-[11px] text-zinc-600 cursor-pointer hover:text-zinc-400 transition-colors py-2 flex items-center gap-1">
                                <span class="collapse-arrow transition-transform duration-200">▶</span> ${altThrowPlans.length} 个其他投技路线
                            </summary>
                            <div class="mt-2 bg-zinc-900/50 p-3 border border-zinc-800">
                                ${altThrowContent}
                            </div>
                        </details>
                    `;
                }

                return `
                    <div class="trend-card">
                        <div onclick="toggleAdvExpand(${group.adv})" class="px-4 sm:px-5 py-3 cursor-pointer text-zinc-300 hover:text-white text-sm font-bold transition-colors select-none flex items-center gap-2 border-b" style="border-color: var(--theme-card-border);">
                            <span class="text-zinc-500 text-xs">▼</span>
                            收起 +${group.adv}F 详细方案
                        </div>
                        <div class="p-4 sm:p-6">
                            <div class="flex flex-col lg:flex-row gap-4 sm:gap-6">
                                ${leftPanel}
                                <div class="flex-1 min-w-0">
                                    ${mainHtml}
                                    ${altHtml}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderLibrary() {
            const body = document.getElementById('moveTableBody');
            
            if (state.moveLibrary.length === 0) {
                body.innerHTML = `
                    <tr>
                        <td colspan="7" class="p-8 text-center text-zinc-600">
                            暂无数据，请粘贴 JSON 导入 ${state.currentCharacter} 的帧数据
                        </td>
                    </tr>
                `;
                return;
            }
            
            // 获取原始预设数据的招式名称列表，用于判断是否可删除
            const defaultMoves = getDefaultMoves(state.currentCharacter);
            const defaultMoveNames = new Set(defaultMoves.map(m => m.name.toUpperCase()));

            body.innerHTML = state.moveLibrary.map((m, idx) => {
                // 判断是否为用户添加的招式（可删除）
                const isUserAdded = m.isUserAdded || !defaultMoveNames.has(m.name.toUpperCase());
                const deleteBtn = isUserAdded 
                    ? `<button onclick="removeMove(${idx})" class="text-zinc-700 hover:text-red-500 transition-colors p-2 -m-1 text-base" title="删除">✕</button>`
                    : '';
                const userBadge = isUserAdded 
                    ? '<span class="ml-1 text-[9px] px-1 py-0.5 bg-emerald-900/50 text-emerald-400 rounded">NEW</span>' 
                    : '';
                
                // 特殊处理 Dash 招式
                if (m.isDash) {
                    return `
                        <tr class="border-b border-zinc-900 hover:bg-zinc-800/20">
                            <td class="p-4 text-zinc-300">${m.name}${userBadge} <span class="text-[10px] text-zinc-500">DASH</span></td>
                            <td class="p-4 text-center font-mono text-zinc-500" colspan="3">${m.dashFrames || 19}F 总帧数 (仅卡帧用)</td>
                            <td class="p-4 text-center font-mono text-zinc-600">-</td>
                            <td class="p-4 text-center font-mono text-zinc-600">-</td>
                            <td class="p-4 text-right">${deleteBtn}</td>
                        </tr>
                    `;
                }
                
                // 特殊处理投技
                if (m.isThrow) {
                    return `
                        <tr class="border-b border-zinc-900 hover:bg-zinc-800/20">
                            <td class="p-4 text-zinc-300">${m.name}${userBadge} <span class="text-[10px] text-zinc-500">THROW</span></td>
                            <td class="p-4 text-center font-mono text-zinc-500">${m.startup}</td>
                            <td class="p-4 text-center font-mono text-zinc-500">${m.active}</td>
                            <td class="p-4 text-center font-mono text-zinc-500">${m.recovery}</td>
                            <td class="p-4 text-center font-mono text-zinc-600">-</td>
                            <td class="p-4 text-center font-mono text-zinc-600">-</td>
                            <td class="p-4 text-right">${deleteBtn}</td>
                        </tr>
                    `;
                }
                
                // 普通招式
                const knockdownBadge = m.isKnockdown 
                    ? '<span class="ml-1 text-[9px] px-1 py-0.5 bg-red-900/50 text-red-400 rounded">KD</span>' 
                    : '';
                    
                return `
                    <tr class="border-b border-zinc-900 hover:bg-zinc-800/20">
                        <td class="p-4 text-zinc-300">${m.name}${userBadge}${knockdownBadge}</td>
                        <td class="p-4 text-center font-mono text-zinc-500">${m.startup}</td>
                        <td class="p-4 text-center font-mono text-zinc-500">${m.active}</td>
                        <td class="p-4 text-center font-mono text-zinc-500">${m.recovery}</td>
                        <td class="p-4 text-center font-mono ${getFrameColorClass(m.hit)}">${m.hit >= 0 ? '+' : ''}${m.hit}</td>
                        <td class="p-4 text-center font-mono ${getFrameColorClass(m.block)}">${m.block >= 0 ? '+' : ''}${m.block}</td>
                        <td class="p-4 text-right">${deleteBtn}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderAll() {
            renderThrowMixups();
            renderNotes();
            renderLibrary();
            renderRules();
        }
        
        // ==================== 打投择方案计算 ====================
        // 当前选中的打投择Tab
        let currentMixupTab = 5;
        
        // 获取场景的 context（用户自定义或预设）
        function getContextForAdv(adv) {
            const contexts = [];
            state.notes.forEach(note => {
                if (note.adv === adv && note.context) {
                    contexts.push(note.context);
                }
            });
            return contexts;
        }
        
        // 计算所有能卡出特定剩余帧的场景
        function calculateThrowMixups() {
            const results = {
                3: [], 4: [], 5: []
            };
            
            if (state.moveLibrary.length === 0) return results;
            
            // 遍历 6-50 帧
            for (let adv = 6; adv <= 50; adv++) {
                const plans = calculateBestPlan(adv);
                
                // 收集每个剩余帧数的所有卡帧方式
                const remainPlans = { 3: [], 4: [], 5: [] };
                
                for (const plan of plans) {
                    // 跳过投技方案（投技不适合打投择）
                    if (plan.isThrow) continue;
                    // 跳过直接压制（不需要卡帧）
                    if (plan.isDirect) continue;
                    
                    const remain = plan.remain;
                    
                    // 只关注 3-5 帧的剩余
                    if (remain < 3 || remain > 5) continue;
                    
                    // 生成卡帧描述
                    // 对于打投择，我们只关心"能卡出特定帧数"，不关心顺序
                    // 所以统一用排序后的格式避免重复（如 "5LP → 66" 和 "5LP + 66" 视为相同）
                    let killDesc;
                    if (plan.killMove2) {
                        // 两步卡帧统一排序后用 "+" 连接
                        const names = [plan.killMove.name, plan.killMove2.name].sort();
                        killDesc = names.join(' + ');
                    } else {
                        killDesc = plan.killMove.name;
                    }
                    
                    // 避免同一帧数的重复卡帧方式
                    if (!remainPlans[remain].includes(killDesc)) {
                        remainPlans[remain].push(killDesc);
                    }
                }
                
                // 为每个有有效方案的剩余帧创建条目
                for (let r = 3; r <= 5; r++) {
                    if (remainPlans[r].length > 0) {
                        const contexts = getContextForAdv(adv);
                        results[r].push({
                            adv,
                            remain: r,
                            killDescs: remainPlans[r],  // 改为数组，包含所有卡帧方式
                            contexts
                        });
                    }
                }
            }
            
            // 按有利帧排序
            for (let i = 3; i <= 5; i++) {
                results[i].sort((a, b) => a.adv - b.adv);
            }
            
            return results;
        }
        
        // 切换打投择Tab
        function switchMixupTab(frame) {
            currentMixupTab = frame;
            
            // 更新 tab 按钮状态
            document.querySelectorAll('.mixup-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mixupTab${frame}`).classList.add('active');
            
            // 重新渲染内容
            renderThrowMixupContent();
        }
        
        // 渲染打投择方案
        function renderThrowMixups() {
            renderThrowMixupContent();
        }
        
        // 渲染打投择内容
        function renderThrowMixupContent() {
            const container = document.getElementById('throwMixupContent');
            
            if (state.moveLibrary.length === 0) {
                container.innerHTML = '<p class="text-zinc-600 text-sm">📭 暂无角色数据</p>';
                return;
            }
            
            const mixups = calculateThrowMixups();
            const items = mixups[currentMixupTab];
            
            // 处理每个item的killDescs，过滤掉被隐藏的
            const processedItems = items.map(item => {
                const visibleDescs = item.killDescs.filter(desc => 
                    !isMixupHidden(item.adv, currentMixupTab, desc)
                );
                return { ...item, killDescs: visibleDescs };
            }).filter(item => item.killDescs.length > 0);
            
            // 分离有场景和无场景的方案
            const withContext = processedItems.filter(item => item.contexts.length > 0);
            const withoutContext = processedItems.filter(item => item.contexts.length === 0);
            
            // 检查某个场景是否有任何收藏的方案
            const hasAnyFavorite = (item) => {
                return item.killDescs.some(desc => isMixupFavorite(item.adv, currentMixupTab, desc));
            };
            
            let mainHtml = '';
            
            if (withContext.length > 0) {
                mainHtml = withContext.map(item => {
                    const hasFav = hasAnyFavorite(item);
                    const contextHtml = `<div class="mt-2 flex flex-wrap gap-1.5">
                        ${item.contexts.map(ctx => `<span class="text-xs px-2.5 py-1 bg-zinc-700/80 text-zinc-200 font-bold">${escapeHtml(ctx)}</span>`).join('')}
                    </div>`;
                    
                    // 多种卡帧方式用"或"连接，收藏的方案高亮显示
                    const killDescsHtml = item.killDescs.map(desc => {
                        const isFav = isMixupFavorite(item.adv, currentMixupTab, desc);
                        const textClass = isFav ? 'text-yellow-300' : 'text-white';
                        if (desc.includes(' + ')) {
                            const parts = desc.split(' + ');
                            return parts.map(p => `<span class="${textClass} font-black text-lg">${p}</span>`).join('<span class="text-yellow-500 mx-1 font-bold">+</span>');
                        } else if (desc.includes(' → ')) {
                            const parts = desc.split(' → ');
                            return parts.map(p => `<span class="${textClass} font-black text-lg">${p}</span>`).join('<span class="text-zinc-600 mx-1 font-bold">→</span>');
                        }
                        return `<span class="${textClass} font-black text-lg">${desc}</span>`;
                    }).join('<span class="text-zinc-500 mx-2">或</span>');
                    
                    // 生成复制文本（所有场景用"/"连接，转义特殊字符）
                    const contextStr = item.contexts.length > 0 ? item.contexts.join('/') : '';
                    const killDescText = item.killDescs.join(' 或 ');
                    const mixupCopyText = `+${item.adv}F ${contextStr}：${killDescText} —— ${currentMixupTab}F 打投择`
                        .replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
                    
                    // 收藏按钮状态
                    const favIcon = hasFav ? '★' : '☆';
                    const favClass = hasFav ? 'text-yellow-400' : 'text-zinc-400 hover:text-yellow-400';
                    const borderColor = hasFav ? 'border-yellow-500' : '';
                    const bgColor = hasFav ? 'bg-yellow-900/10' : 'bg-zinc-900/50';
                    
                    return `
                        <div class="py-3 px-4 ${bgColor} border-l-4 mb-3 relative group ${borderColor}" style="border-left-color: ${hasFav ? '#eab308' : 'var(--theme-primary)'};">
                            <div class="absolute top-1.5 sm:top-2 right-1.5 sm:right-2 flex gap-0.5 sm:gap-1 opacity-80 group-hover:opacity-100">
                                <button onclick="copyPlanInfo(\`${mixupCopyText}\`)" class="text-zinc-500 hover:text-cyan-400 transition-colors p-2 sm:p-1 text-base sm:text-sm opacity-70 hover:opacity-100" title="复制方案">📋</button>
                                <button onclick="openMixupEditModal(${item.adv}, ${currentMixupTab})" class="text-zinc-400 hover:text-cyan-400 transition-colors p-2 sm:p-1 text-base sm:text-sm opacity-60 hover:opacity-100" title="编辑方案">✏️</button>
                                <button onclick="toggleMixupFavoriteAll(${item.adv}, ${currentMixupTab})" class="${favClass} transition-colors p-2 sm:p-1 text-lg sm:text-base" title="${hasFav ? '取消收藏' : '收藏方案'}">${favIcon}</button>
                            </div>
                            <div class="flex items-center gap-3 flex-wrap pr-24 sm:pr-20">
                                <span class="impact-text text-2xl font-black" style="color: var(--theme-secondary);">+${item.adv}F</span>
                                ${killDescsHtml}
                            </div>
                            ${contextHtml}
                            ${hasFav ? '<div class="favorite-stamp">FAVE</div>' : ''}
                        </div>
                    `;
                }).join('');
            }
            
            // 无场景方案的折叠区域
            let noContextHtml = '';
            if (withoutContext.length > 0) {
                const noContextItems = withoutContext.map(item => {
                    const hasFav = hasAnyFavorite(item);
                    const killDescsHtml = item.killDescs.map(desc => {
                        const isFav = isMixupFavorite(item.adv, currentMixupTab, desc);
                        const textClass = isFav ? 'text-yellow-300' : 'text-zinc-300';
                        if (desc.includes(' + ')) {
                            const parts = desc.split(' + ');
                            return parts.map(p => `<span class="${textClass} font-bold">${p}</span>`).join('<span class="text-yellow-600 mx-1 font-bold">+</span>');
                        } else if (desc.includes(' → ')) {
                            const parts = desc.split(' → ');
                            return parts.map(p => `<span class="${textClass} font-bold">${p}</span>`).join('<span class="text-zinc-600 mx-1 font-bold">→</span>');
                        }
                        return `<span class="${textClass} font-bold">${desc}</span>`;
                    }).join('<span class="text-zinc-500 mx-1">或</span>');
                    
                    const killDescText = item.killDescs.join(' 或 ');
                    const mixupCopyText = `+${item.adv}F：${killDescText} —— ${currentMixupTab}F 打投择`
                        .replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/\$/g, '\\$');
                    
                    const favIcon = hasFav ? '★' : '☆';
                    const favClass = hasFav ? 'text-yellow-400' : 'text-zinc-400 hover:text-yellow-400';
                    const bgColor = hasFav ? 'bg-yellow-900/10' : 'bg-black/20';
                    
                    return `
                        <div class="py-2 sm:py-1.5 px-3 ${bgColor} border-l-2 mb-1.5 sm:mb-1 relative group" style="border-left-color: ${hasFav ? '#eab308' : 'var(--theme-card-border)'};">
                            <div class="flex items-center gap-2 flex-wrap text-sm pr-20 sm:pr-16">
                                <span class="font-bold" style="color: var(--theme-secondary);">+${item.adv}F</span>
                                ${killDescsHtml}
                            </div>
                            <div class="absolute right-1.5 sm:right-2 top-1/2 -translate-y-1/2 flex gap-0.5 opacity-80 group-hover:opacity-100">
                                <button onclick="copyPlanInfo(\`${mixupCopyText}\`)" class="text-zinc-500 hover:text-cyan-400 transition-colors p-1.5 sm:p-0.5 text-sm sm:text-xs opacity-70 hover:opacity-100" title="复制方案">📋</button>
                                <button onclick="openMixupEditModal(${item.adv}, ${currentMixupTab})" class="text-zinc-400 hover:text-cyan-400 transition-colors p-1.5 sm:p-0.5 text-sm sm:text-xs opacity-60 hover:opacity-100" title="编辑方案">✏️</button>
                                <button onclick="toggleMixupFavoriteAll(${item.adv}, ${currentMixupTab})" class="${favClass} transition-colors p-1.5 sm:p-0.5 text-sm sm:text-xs" title="${hasFav ? '取消收藏' : '收藏方案'}">${favIcon}</button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                noContextHtml = `
                    <details class="mt-4">
                        <summary class="cursor-pointer text-zinc-500 hover:text-zinc-300 text-xs font-bold transition-colors select-none py-2 flex items-center gap-1">
                            <span class="collapse-arrow transition-transform duration-200">▶</span> 无对应场景的打投择卡帧方案 (${withoutContext.length})
                        </summary>
                        <div class="pt-2">
                            ${noContextItems}
                        </div>
                    </details>
                `;
            }
            
            // 顶部提示
            const countText = withContext.length > 0 
                ? `✓ 找到 ${withContext.length} 个方案可卡出 ${currentMixupTab}F`
                : `暂无对应场景的 ${currentMixupTab}F 打投择卡帧方案`;
            
            container.innerHTML = `
                <div class="text-sm mb-4" style="color: var(--theme-primary);">${countText}</div>
                ${mainHtml}
                ${noContextHtml}
            `;
        }
        
        // 收藏/取消收藏整个打投择场景的所有方案
        function toggleMixupFavoriteAll(adv, remain) {
            const mixups = calculateThrowMixups();
            const item = mixups[remain].find(m => m.adv === adv);
            if (!item) return;
            
            // 检查是否所有方案都已收藏
            const allFavorited = item.killDescs.every(desc => isMixupFavorite(adv, remain, desc));
            
            // 如果全部已收藏，则取消全部；否则收藏全部
            item.killDescs.forEach(desc => {
                const key = getMixupKey(adv, remain, desc);
                if (allFavorited) {
                    delete state.mixupFavorites[key];
                } else {
                    state.mixupFavorites[key] = true;
                }
            });
            
            saveMixupFavorites();
            renderThrowMixupContent();
        }
        
        // 打开打投择编辑弹窗
        function openMixupEditModal(adv, remain) {
            const mixups = calculateThrowMixups();
            const originalItem = mixups[remain].find(m => m.adv === adv);
            if (!originalItem) return;
            
            // 获取所有卡帧方式（包括已隐藏的）
            const allDescs = originalItem.killDescs;
            
            // 创建弹窗HTML
            const modalHtml = `
                <div id="mixupEditModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-3 sm:p-4 z-50" onclick="if(event.target === this) closeMixupEditModal()">
                    <div class="bg-zinc-900 border w-full max-w-md p-5 sm:p-6 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-card-border);">
                        <div class="flex justify-between items-center mb-5 sm:mb-6">
                            <h2 class="text-lg sm:text-xl font-bold text-white">编辑打投择方案</h2>
                            <button onclick="closeMixupEditModal()" class="text-zinc-500 hover:text-white text-3xl sm:text-2xl p-2 -m-2" title="关闭">&times;</button>
                        </div>
                        <div class="mb-4">
                            <div class="text-sm text-zinc-400 mb-2">+${adv}F · ${remain}F 打投择</div>
                            <div class="text-xs text-zinc-500 mb-4">取消勾选可隐藏不需要的卡帧方案</div>
                        </div>
                        <div class="space-y-2 sm:space-y-3 mb-6">
                            ${allDescs.map((desc, i) => {
                                const isHidden = isMixupHidden(adv, remain, desc);
                                return `
                                    <label class="flex items-center gap-3 sm:gap-4 p-3 sm:p-4 bg-zinc-800/50 border border-zinc-700 cursor-pointer hover:bg-zinc-800 active:bg-zinc-700 transition-colors min-h-[48px]">
                                        <input type="checkbox" ${!isHidden ? 'checked' : ''} 
                                            onchange="toggleMixupHidden(${adv}, ${remain}, '${desc.replace(/'/g, "\\'")}')"
                                            class="w-5 h-5 sm:w-4 sm:h-4 accent-cyan-500 flex-shrink-0">
                                        <span class="text-white font-bold text-sm sm:text-base">${desc}</span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                        <div class="flex gap-2 sm:gap-3">
                            <button onclick="resetMixupHidden(${adv}, ${remain})" class="flex-1 px-4 py-3 sm:py-2.5 bg-zinc-700 text-zinc-300 hover:bg-zinc-600 active:bg-zinc-500 transition-colors text-sm font-bold min-h-[44px]">恢复全部</button>
                            <button onclick="closeMixupEditModal()" class="flex-1 px-4 py-3 sm:py-2.5 bg-cyan-600 text-white hover:bg-cyan-500 active:bg-cyan-400 transition-colors text-sm font-bold min-h-[44px]">完成</button>
                        </div>
                    </div>
                </div>
            `;
            
            // 添加到body
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 添加ESC关闭支持
            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    closeMixupEditModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            };
            document.addEventListener('keydown', handleEsc);
        }
        
        // 关闭打投择编辑弹窗
        function closeMixupEditModal() {
            const modal = document.getElementById('mixupEditModal');
            if (modal) modal.remove();
        }
        
        // 恢复某个场景的所有隐藏
        function resetMixupHidden(adv, remain) {
            const mixups = calculateThrowMixups();
            const item = mixups[remain].find(m => m.adv === adv);
            if (!item) return;
            
            item.killDescs.forEach(desc => {
                const key = getMixupKey(adv, remain, desc);
                delete state.mixupHidden[key];
            });
            
            saveMixupHidden();
            closeMixupEditModal();
            openMixupEditModal(adv, remain);
            renderThrowMixupContent();
        }
        
        // ==================== 模板管理 UI ====================
        
        // 更新模板选择器显示
        function updateTemplateSelector() {
            const template = getCurrentTemplate();
            const nameSpan = document.getElementById('currentTemplateName');
            if (nameSpan) {
                nameSpan.textContent = template.name;
            }
        }
        
        // 切换模板下拉菜单
        function toggleTemplateDropdown() {
            const dropdown = document.getElementById('templateDropdown');
            const isHidden = dropdown.classList.contains('hidden');
            
            if (isHidden) {
                // 更新下拉列表内容
                renderTemplateDropdown();
                dropdown.classList.remove('hidden');
                
                // 点击外部关闭
                setTimeout(() => {
                    document.addEventListener('click', closeTemplateDropdownOnClickOutside);
                }, 0);
            } else {
                dropdown.classList.add('hidden');
                document.removeEventListener('click', closeTemplateDropdownOnClickOutside);
            }
        }
        
        function closeTemplateDropdownOnClickOutside(e) {
            const dropdown = document.getElementById('templateDropdown');
            const btn = document.getElementById('templateSelectorBtn');
            if (!dropdown.contains(e.target) && !btn.contains(e.target)) {
                dropdown.classList.add('hidden');
                document.removeEventListener('click', closeTemplateDropdownOnClickOutside);
            }
        }
        
        // 渲染模板下拉列表
        function renderTemplateDropdown() {
            const listDiv = document.getElementById('templateDropdownList');
            const templates = getAllTemplates();
            const currentId = state.favoriteTemplates[state.currentCharacter].current;
            
            const items = [];
            Object.entries(templates).forEach(([id, template]) => {
                if (id !== currentId) {  // 不显示当前选中的
                    const isActive = id === currentId;
                    items.push(`
                        <button onclick="switchTemplate('${id}'); toggleTemplateDropdown();" 
                            class="w-full px-4 py-2.5 text-left hover:bg-zinc-800 transition-colors text-white font-bold text-sm flex items-center justify-between gap-2">
                            <span>${escapeHtml(template.name)}</span>
                            ${isActive ? '<span style="color: var(--theme-primary);">✓</span>' : ''}
                        </button>
                    `);
                }
            });
            
            if (items.length === 0) {
                listDiv.innerHTML = '<div class="px-4 py-3 text-zinc-500 text-sm">暂无其他模板</div>';
            } else {
                listDiv.innerHTML = items.join('');
            }
        }
        
        // 打开模板管理弹窗
        function openTemplateManageModal() {
            const templates = getAllTemplates();
            const templateItems = [];
            
            Object.entries(templates).forEach(([id, template]) => {
                if (id !== 'my') {  // "我的收藏"不可删除
                    const favCount = (template.favorites || []).length + (template.mixupFavorites || []).length;
                    templateItems.push(`
                        <label class="flex items-center gap-3 p-4 bg-zinc-800/50 border border-zinc-700 cursor-pointer hover:bg-zinc-800 transition-colors">
                            <input type="checkbox" class="template-delete-checkbox w-5 h-5 accent-red-500 flex-shrink-0" data-template-id="${id}">
                            <div class="flex-1">
                                <div class="text-white font-bold">${escapeHtml(template.name)}</div>
                                <div class="text-xs text-zinc-500 mt-1">${favCount} 个收藏方案</div>
                            </div>
                        </label>
                    `);
                }
            });
            
            const modalHtml = `
                <div id="templateManageModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-50" onclick="if(event.target === this) closeTemplateManageModal()">
                    <div class="bg-zinc-900 border-2 w-full max-w-md p-6 max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-primary);">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-xl font-bold text-white">管理收藏模板</h2>
                            <button onclick="closeTemplateManageModal()" class="text-zinc-500 hover:text-white text-2xl p-2 -m-2" title="关闭">&times;</button>
                        </div>
                        ${templateItems.length > 0 ? `
                            <div class="mb-4">
                                <div class="text-sm text-zinc-400 mb-3">选择要删除的模板：</div>
                                <div class="space-y-2 mb-6">
                                    ${templateItems.join('')}
                                </div>
                            </div>
                            <div class="flex gap-3">
                                <button onclick="closeTemplateManageModal()" class="flex-1 px-4 py-2.5 bg-zinc-700 text-zinc-300 hover:bg-zinc-600 transition-colors text-sm font-bold">取消</button>
                                <button onclick="confirmDeleteTemplates()" class="flex-1 px-4 py-2.5 bg-red-600 text-white hover:bg-red-500 transition-colors text-sm font-bold">删除选中</button>
                            </div>
                        ` : `
                            <div class="text-center py-8 text-zinc-500">
                                暂无可管理的模板
                            </div>
                        `}
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        function closeTemplateManageModal() {
            const modal = document.getElementById('templateManageModal');
            if (modal) modal.remove();
        }
        
        function confirmDeleteTemplates() {
            const checkboxes = document.querySelectorAll('.template-delete-checkbox:checked');
            const templateIds = Array.from(checkboxes).map(cb => cb.dataset.templateId);
            
            if (templateIds.length === 0) {
                closeTemplateManageModal();
                return;
            }
            
            // 删除选中的模板
            templateIds.forEach(id => deleteTemplate(id));
            
            closeTemplateManageModal();
            renderFavoritesView();
        }
        
        // 打开导入/导出弹窗
        function openImportExportModal() {
            const currentTemplate = getCurrentTemplate();
            const exportJson = exportCurrentTemplate();
            
            const modalHtml = `
                <div id="importExportModal" class="fixed inset-0 bg-black/90 backdrop-blur-sm flex items-center justify-center p-4 z-50" onclick="if(event.target === this) closeImportExportModal()">
                    <div class="bg-zinc-900 border-2 w-full max-w-2xl max-h-[90vh] overflow-y-auto" style="border-color: var(--theme-primary);">
                        <div class="sticky top-0 bg-zinc-900 border-b border-zinc-700 p-6 pb-4 z-10">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-bold text-white">导入/导出收藏模板</h2>
                                <button onclick="closeImportExportModal()" class="text-zinc-500 hover:text-white text-2xl p-2 -m-2" title="关闭">&times;</button>
                            </div>
                            <div class="flex gap-2">
                                <button id="importTab" onclick="switchImportExportTab('import')" class="flex-1 px-4 py-2 text-sm font-bold transition-all border-b-2" style="color: var(--theme-primary); border-color: var(--theme-primary);">导入</button>
                                <button id="exportTab" onclick="switchImportExportTab('export')" class="flex-1 px-4 py-2 text-sm font-bold transition-all border-b-2 border-transparent text-zinc-500 hover:text-zinc-300">导出</button>
                            </div>
                        </div>
                        
                        <div class="p-6">
                            <!-- 导入面板 -->
                            <div id="importPanel">
                                <div class="space-y-4">
                                    <div>
                                        <label class="block text-sm text-zinc-400 mb-2">模板名称</label>
                                        <input type="text" id="importTemplateName" placeholder="${escapeHtml(getDefaultTemplateName(state.currentCharacter))}" 
                                            class="w-full px-4 py-2.5 bg-zinc-800 border border-zinc-600 text-white focus:border-cyan-500 focus:outline-none transition-colors text-sm">
                                    </div>
                                    <div>
                                        <div class="flex justify-between items-center mb-2">
                                            <label class="text-sm text-zinc-400">模板数据</label>
                                            <button onclick="toggleFormatHelp()" class="text-xs text-cyan-500 hover:text-cyan-400 transition-colors">点击查看格式说明</button>
                                        </div>
                                        <textarea id="importTemplateData" rows="12" 
                                            class="w-full px-4 py-3 bg-zinc-800 border border-zinc-600 text-white focus:border-cyan-500 focus:outline-none transition-colors font-mono text-xs"
                                            placeholder='{\n  "character": "RYU",\n  "favorites": [...],\n  "mixupFavorites": [...]\n}'></textarea>
                                        
                                        <!-- 格式说明 -->
                                        <div id="formatHelp" class="hidden mt-3 p-4 bg-zinc-800/50 border border-zinc-700 text-xs">
                                            <div class="text-zinc-300 font-bold mb-2">格式说明</div>
                                            <div class="text-zinc-400 space-y-2">
                                                <div>必须包含以下字段：</div>
                                                <div class="pl-3">• <span class="text-cyan-400">character</span>: 角色名称（如 "RYU"）</div>
                                                <div class="pl-3">• <span class="text-cyan-400">favorites</span>: 压制方案数组</div>
                                                <div class="pl-3">• <span class="text-cyan-400">mixupFavorites</span>: 打投择方案数组</div>
                                                <div class="mt-3 pt-3 border-t border-zinc-700">
                                                    <div class="text-zinc-300 mb-1">示例：</div>
                                                    <pre class="text-[10px] text-zinc-500 overflow-x-auto">{
  "character": "RYU",
  "favorites": ["DIRECT||5MP|18"],
  "mixupFavorites": ["18|0|投技"]
}</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="importError" class="hidden text-red-400 text-sm p-3 bg-red-900/20 border border-red-800"></div>
                                </div>
                                <div class="flex justify-end mt-6">
                                    <button onclick="confirmImport()" class="px-6 py-2.5 bg-cyan-600 text-white hover:bg-cyan-500 transition-colors text-sm font-bold">确认导入</button>
                                </div>
                            </div>
                            
                            <!-- 导出面板 -->
                            <div id="exportPanel" class="hidden">
                                <div class="mb-4">
                                    <div class="text-sm text-zinc-400 mb-2">当前模板：<span class="text-white font-bold">${escapeHtml(currentTemplate.name)}</span></div>
                                    <textarea id="exportTemplateData" readonly rows="16" 
                                        class="w-full px-4 py-3 bg-zinc-800 border border-zinc-600 text-zinc-300 font-mono text-xs overflow-auto">${escapeHtml(exportJson)}</textarea>
                                </div>
                                <div class="flex justify-end">
                                    <button onclick="copyExportData()" class="px-6 py-2.5 bg-zinc-700 text-zinc-300 hover:bg-zinc-600 hover:text-white transition-colors text-sm font-bold flex items-center gap-2">
                                        <span>📋</span>
                                        <span id="copyBtnText">复制</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        function closeImportExportModal() {
            const modal = document.getElementById('importExportModal');
            if (modal) modal.remove();
        }
        
        function switchImportExportTab(tab) {
            const importTab = document.getElementById('importTab');
            const exportTab = document.getElementById('exportTab');
            const importPanel = document.getElementById('importPanel');
            const exportPanel = document.getElementById('exportPanel');
            
            if (tab === 'import') {
                importTab.style.color = 'var(--theme-primary)';
                importTab.style.borderColor = 'var(--theme-primary)';
                exportTab.style.color = '';
                exportTab.style.borderColor = 'transparent';
                importPanel.classList.remove('hidden');
                exportPanel.classList.add('hidden');
            } else {
                exportTab.style.color = 'var(--theme-primary)';
                exportTab.style.borderColor = 'var(--theme-primary)';
                importTab.style.color = '';
                importTab.style.borderColor = 'transparent';
                exportPanel.classList.remove('hidden');
                importPanel.classList.add('hidden');
            }
        }
        
        function toggleFormatHelp() {
            const help = document.getElementById('formatHelp');
            help.classList.toggle('hidden');
        }
        
        function confirmImport() {
            const nameInput = document.getElementById('importTemplateName');
            const dataInput = document.getElementById('importTemplateData');
            const errorDiv = document.getElementById('importError');
            
            const templateName = nameInput.value.trim() || nameInput.placeholder;
            const dataStr = dataInput.value.trim();
            
            // 验证名称
            const nameValidation = validateTemplateName(state.currentCharacter, templateName);
            if (!nameValidation.valid) {
                errorDiv.textContent = nameValidation.error;
                errorDiv.classList.remove('hidden');
                return;
            }
            
            // 验证 JSON
            let data;
            try {
                data = JSON.parse(dataStr);
            } catch (e) {
                errorDiv.textContent = 'JSON 格式错误：' + e.message;
                errorDiv.classList.remove('hidden');
                return;
            }
            
            // 验证必需字段
            if (!data.character || !Array.isArray(data.favorites) || !Array.isArray(data.mixupFavorites)) {
                errorDiv.textContent = '缺少必需字段：character, favorites, mixupFavorites';
                errorDiv.classList.remove('hidden');
                return;
            }
            
            // 角色不匹配？
            if (data.character !== state.currentCharacter) {
                showCharacterMismatchWarning(data.character, templateName, data);
                return;
            }
            
            // 导入
            importTemplate(data, templateName);
            closeImportExportModal();
            renderFavoritesView();
        }
        
        function showCharacterMismatchWarning(targetChar, templateName, data) {
            const modalHtml = `
                <div id="charMismatchModal" class="fixed inset-0 bg-black/95 backdrop-blur-sm flex items-center justify-center p-4 z-[60]">
                    <div class="bg-zinc-900 border-2 border-red-500 w-full max-w-md p-6">
                        <h2 class="text-xl font-bold text-white mb-4">角色不匹配</h2>
                        <div class="text-zinc-300 mb-6 space-y-2">
                            <p>导入的模板是 <span class="font-bold text-yellow-400">${targetChar}</span> 的收藏方案</p>
                            <p>当前查看的是 <span class="font-bold" style="color: var(--theme-primary);">${state.currentCharacter}</span></p>
                            <p class="text-sm text-zinc-400 mt-4">是否切换到 ${targetChar} 并导入？</p>
                        </div>
                        <div class="flex gap-3">
                            <button onclick="closeCharMismatchModal()" class="flex-1 px-4 py-2.5 bg-zinc-700 text-zinc-300 hover:bg-zinc-600 transition-colors text-sm font-bold">取消</button>
                            <button onclick="confirmCharSwitch('${targetChar}', '${escapeHtml(templateName).replace(/'/g, "\\'")}', ${escapeHtml(JSON.stringify(data))})" class="flex-1 px-4 py-2.5 bg-cyan-600 text-white hover:bg-cyan-500 transition-colors text-sm font-bold">确认切换</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }
        
        function closeCharMismatchModal() {
            const modal = document.getElementById('charMismatchModal');
            if (modal) modal.remove();
        }
        
        function confirmCharSwitch(targetChar, templateName, data) {
            closeCharMismatchModal();
            closeImportExportModal();
            
            // 切换角色
            selectCharacter(targetChar);
            
            // 导入模板
            setTimeout(() => {
                importTemplate(data, templateName);
                // 切换到收藏视图
                if (!state.showOnlyFavorites) {
                    toggleShowOnlyFavorites();
                } else {
                    renderFavoritesView();
                }
            }, 100);
        }
        
        function copyExportData() {
            const textarea = document.getElementById('exportTemplateData');
            const btnText = document.getElementById('copyBtnText');
            
            textarea.select();
            document.execCommand('copy');
            
            // 视觉反馈
            const originalText = btnText.textContent;
            btnText.textContent = '已复制！';
            setTimeout(() => {
                btnText.textContent = originalText;
            }, 2000);
        }
        
        // 显示模板修改警告
        function showTemplateModifyWarning(templateName, onConfirm) {
            const modalHtml = `
                <div id="templateModifyWarning" class="fixed inset-0 bg-black/95 backdrop-blur-sm flex items-center justify-center p-4 z-[60]">
                    <div class="bg-zinc-900 border-2 w-full max-w-md p-6" style="border-color: var(--theme-primary);">
                        <h2 class="text-xl font-bold text-white mb-4">提示</h2>
                        <div class="text-zinc-300 mb-6 space-y-2">
                            <p>当前正在修改 <span class="font-bold" style="color: var(--theme-primary);">[${escapeHtml(templateName)}]</span> 模板</p>
                            <p class="text-sm text-zinc-400">是否继续？</p>
                            <label class="flex items-center gap-2 mt-4 text-sm text-zinc-500">
                                <input type="checkbox" id="dontShowAgain" class="w-4 h-4 accent-cyan-500">
                                <span>下次操作不再提示</span>
                            </label>
                        </div>
                        <div class="flex gap-3">
                            <button onclick="closeTemplateModifyWarning()" class="flex-1 px-4 py-2.5 bg-zinc-700 text-zinc-300 hover:bg-zinc-600 transition-colors text-sm font-bold">取消</button>
                            <button onclick="confirmTemplateModify()" class="flex-1 px-4 py-2.5 bg-cyan-600 text-white hover:bg-cyan-500 transition-colors text-sm font-bold">确认</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            
            // 存储回调
            window._templateModifyCallback = onConfirm;
        }
        
        function closeTemplateModifyWarning() {
            const modal = document.getElementById('templateModifyWarning');
            if (modal) modal.remove();
            delete window._templateModifyCallback;
        }
        
        function confirmTemplateModify() {
            const dontShow = document.getElementById('dontShowAgain').checked;
            closeTemplateModifyWarning();
            
            if (window._templateModifyCallback) {
                window._templateModifyCallback();
                delete window._templateModifyCallback;
            }
        }

        // ==================== 事件处理 ====================
        function openCharacterModal() { 
            initCharacterGrid();
            document.getElementById('charModal').classList.remove('hidden'); 
        }
        
        function closeCharModal() { 
            document.getElementById('charModal').classList.add('hidden'); 
        }
        
        function openHelpModal() {
            document.getElementById('helpModal').classList.remove('hidden');
        }
        
        function closeHelpModal() {
            document.getElementById('helpModal').classList.add('hidden');
        }
        
        function openRuleModal() {
            // 填充招式下拉列表
            populateMoveSelects();
            // 默认显示禁用压制tab
            switchRuleTab('disable');
            document.getElementById('ruleModal').classList.remove('hidden');
        }
        
        function closeRuleModal() {
            document.getElementById('ruleModal').classList.add('hidden');
            // 清空所有输入
            document.getElementById('inputDisableMove').value = '';
            document.getElementById('inputDisableUsage').value = 'kill';
            document.getElementById('inputDisableDesc').value = '';
            document.getElementById('inputComboMove1').value = '';
            document.getElementById('inputComboMove2').value = '';
            document.getElementById('inputComboDesc').value = '';
            document.getElementById('inputPreferMove').value = '';
            document.getElementById('inputPreferDesc').value = '';
        }
        
        // 切换规则类型 tab
        function switchRuleTab(type) {
            // 更新 tab 按钮状态
            document.querySelectorAll('.rule-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`ruleTab-${type}`).classList.add('active');
            
            // 显示/隐藏表单
            document.getElementById('ruleForm-disable').classList.toggle('hidden', type !== 'disable');
            document.getElementById('ruleForm-combo').classList.toggle('hidden', type !== 'combo');
            document.getElementById('ruleForm-prefer').classList.toggle('hidden', type !== 'prefer');
        }
        
        // 填充招式下拉列表
        function populateMoveSelects() {
            const moves = state.moveLibrary.map(m => m.name).sort();
            
            // 禁用压制规则的下拉
            const disableSelect = document.getElementById('inputDisableMove');
            disableSelect.innerHTML = '<option value="">-- 请选择招式 --</option>' +
                moves.map(m => `<option value="${m}">${m}</option>`).join('');
            
            // 禁用组合规则的两个下拉
            const comboSelect1 = document.getElementById('inputComboMove1');
            const comboSelect2 = document.getElementById('inputComboMove2');
            const optionsHtml = '<option value="">-- 请选择招式 --</option>' +
                moves.map(m => `<option value="${m}">${m}</option>`).join('');
            comboSelect1.innerHTML = optionsHtml;
            comboSelect2.innerHTML = optionsHtml;
            
            // 倾向压制规则的下拉
            const preferSelect = document.getElementById('inputPreferMove');
            preferSelect.innerHTML = '<option value="">-- 请选择招式 --</option>' +
                moves.map(m => `<option value="${m}">${m}</option>`).join('');
        }
        
        // 保存禁用压制规则
        function saveDisableRule() {
            const moveName = document.getElementById('inputDisableMove').value.trim();
            const usage = document.getElementById('inputDisableUsage').value;
            const description = document.getElementById('inputDisableDesc').value.trim();
            
            if (!moveName) {
                showToast('请选择招式', 'error');
                return;
            }
            
            const usageLabels = {
                'kill': '用于卡帧',
                'meaty_after_kill': '用于卡帧后压制',
                'meaty_direct': '用于直接压制'
            };
            
            const newRule = {
                id: `rule_${Date.now()}`,
                type: 'disable',
                moveName,
                usage,
                description: description || `禁止 ${moveName} ${usageLabels[usage]}`
            };
            
            // 添加到角色专属规则
            if (!state.characterRules[state.currentCharacter]) {
                state.characterRules[state.currentCharacter] = [];
            }
            state.characterRules[state.currentCharacter].push(newRule);
            
            // 保存到 localStorage
            saveCharacterRules(state.currentCharacter, state.characterRules[state.currentCharacter]);
            
            closeRuleModal();
            renderRules();
            renderNotes(); // 重新计算方案
            showToast('规则已添加');
        }
        
        // 保存禁用组合规则
        function saveComboRule() {
            const move1 = document.getElementById('inputComboMove1').value.trim();
            const move2 = document.getElementById('inputComboMove2').value.trim();
            const description = document.getElementById('inputComboDesc').value.trim();
            
            if (!move1 || !move2) {
                showToast('请选择两个招式', 'error');
                return;
            }
            
            if (move1 === move2) {
                showToast('请选择不同的招式', 'error');
                return;
            }
            
            const newRule = {
                id: `rule_${Date.now()}`,
                type: 'combo',
                move1,
                move2,
                description: description || `${move1} × ${move2} 禁止连续使用`
            };
            
            // 添加到角色专属规则
            if (!state.characterRules[state.currentCharacter]) {
                state.characterRules[state.currentCharacter] = [];
            }
            state.characterRules[state.currentCharacter].push(newRule);
            
            // 保存到 localStorage
            saveCharacterRules(state.currentCharacter, state.characterRules[state.currentCharacter]);
            
            closeRuleModal();
            renderRules();
            renderNotes(); // 重新计算方案
            showToast('规则已添加');
        }
        
        // 保存倾向压制规则
        function savePreferRule() {
            const moveName = document.getElementById('inputPreferMove').value.trim();
            const description = document.getElementById('inputPreferDesc').value.trim();
            
            if (!moveName) {
                showToast('请选择招式', 'error');
                return;
            }
            
            const newRule = {
                id: `rule_${Date.now()}`,
                type: 'prefer',
                moveName,
                description: description || `倾向使用 ${moveName} 进行压制`
            };
            
            // 添加到角色专属规则
            if (!state.characterRules[state.currentCharacter]) {
                state.characterRules[state.currentCharacter] = [];
            }
            state.characterRules[state.currentCharacter].push(newRule);
            
            // 保存到 localStorage
            saveCharacterRules(state.currentCharacter, state.characterRules[state.currentCharacter]);
            
            closeRuleModal();
            renderRules();
            renderNotes(); // 重新计算方案
            showToast('规则已添加');
        }
        
        function saveRule() {
            const pattern1 = document.getElementById('inputPattern1').value.trim().toUpperCase();
            const pattern2 = document.getElementById('inputPattern2').value.trim().toUpperCase();
            const description = document.getElementById('inputRuleDesc').value.trim();
            
            if (!pattern1 || !pattern2) {
                alert('请填写两个招式关键词');
                return;
            }
            
            // 检查是否与现有规则重复（包括全局规则）
            const allRules = getAllRulesForCharacter(state.currentCharacter);
            const isDuplicate = allRules.some(r => {
                const p1 = r.pattern1.toUpperCase();
                const p2 = r.pattern2.toUpperCase();
                // 双向匹配检查
                return (p1 === pattern1 && p2 === pattern2) || (p1 === pattern2 && p2 === pattern1);
            });
            
            if (isDuplicate) {
                alert('该规则已存在');
                return;
            }
            
            const newRule = {
                id: `rule_${Date.now()}`,
                pattern1,
                pattern2,
                description: description || `${pattern1} × ${pattern2} 禁止组合`
            };
            
            // 添加到角色专属规则
            if (!state.characterRules[state.currentCharacter]) {
                state.characterRules[state.currentCharacter] = [];
            }
            state.characterRules[state.currentCharacter].push(newRule);
            
            // 保存到 localStorage
            saveCharacterRules(state.currentCharacter, state.characterRules[state.currentCharacter]);
            
            closeRuleModal();
            renderRules();
            renderNotes(); // 重新计算方案
            showToast('规则已添加');
        }
        
        function removeRule(ruleId) {
            // 先检查是否是预设规则
            const presetRules = CONFIG.CHARACTER_PRESET_RULES[state.currentCharacter] || [];
            const presetRule = presetRules.find(r => r.id === ruleId);
            
            if (presetRule) {
                // 删除预设规则
                if (!confirm(`确定要删除此预设规则吗？\n${presetRule.description || '预设规则'}\n\n（可通过"重置"恢复）`)) {
                    return;
                }
                // 记录已删除的预设规则
                state.deletedPresetRules[`${state.currentCharacter}:${ruleId}`] = true;
                saveDeletedPresetRules();
                renderRules();
                renderNotes();
                showToast('预设规则已删除');
                return;
            }
            
            // 删除自定义规则
            const rules = state.characterRules[state.currentCharacter] || [];
            const idx = rules.findIndex(r => r.id === ruleId);
            if (idx !== -1) {
                const rule = rules[idx];
                if (!confirm(`确定要删除此规则吗？\n${rule.description || '自定义规则'}`)) {
                    return;
                }
                rules.splice(idx, 1);
                saveCharacterRules(state.currentCharacter, rules);
                renderRules();
                renderNotes();
                showToast('规则已删除');
            }
        }
        
        // 保存已删除的预设规则
        function saveDeletedPresetRules() {
            try {
                localStorage.setItem(`${CONFIG.STORAGE_KEY}_deleted_preset_rules`, JSON.stringify(state.deletedPresetRules));
            } catch (e) {
                console.warn('保存已删除预设规则失败:', e);
            }
        }
        
        // 加载已删除的预设规则
        function loadDeletedPresetRules() {
            try {
                const saved = localStorage.getItem(`${CONFIG.STORAGE_KEY}_deleted_preset_rules`);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.warn('加载已删除预设规则失败:', e);
            }
            return {};
        }
        
        function clearAllRules() {
            const rules = state.characterRules[state.currentCharacter] || [];
            if (rules.length === 0) {
                showToast('没有可清除的规则', 'info');
                return;
            }
            if (!confirm(`确定要清除 ${state.currentCharacter} 的所有 ${rules.length} 条自定义规则吗？\n（全局规则不受影响）`)) {
                return;
            }
            state.characterRules[state.currentCharacter] = [];
            saveCharacterRules(state.currentCharacter, []);
            renderRules();
            renderNotes();
            showToast(`已清除 ${rules.length} 条规则`);
        }
        
        // ==================== 新增招式弹窗 ====================
        let currentMoveType = 'normal';  // normal, throw, dash
        
        function openAddMoveModal() {
            currentMoveType = 'normal';
            updateMoveTypeUI();
            document.getElementById('addMoveModal').classList.remove('hidden');
            document.getElementById('inputMoveName').focus();
        }
        
        function closeAddMoveModal() {
            document.getElementById('addMoveModal').classList.add('hidden');
            // 清空所有输入
            document.getElementById('inputMoveName').value = '';
            document.getElementById('inputMoveStartup').value = '';
            document.getElementById('inputMoveActive').value = '';
            document.getElementById('inputMoveRecovery').value = '';
            document.getElementById('inputMoveHit').value = '';
            document.getElementById('inputMoveBlock').value = '';
            document.getElementById('inputMoveKnockdown').checked = false;
            document.getElementById('inputMoveDashFrames').value = '';
        }
        
        function setMoveType(type) {
            currentMoveType = type;
            updateMoveTypeUI();
        }
        
        function updateMoveTypeUI() {
            const normalBtn = document.getElementById('moveTypeNormal');
            const throwBtn = document.getElementById('moveTypeThrow');
            const dashBtn = document.getElementById('moveTypeDash');
            const frameFields = document.getElementById('moveFrameFields');
            const dashFields = document.getElementById('moveDashFields');
            const hitBlockFields = document.getElementById('moveHitBlockFields');
            const knockdownField = document.getElementById('moveKnockdownField');
            
            // 重置按钮样式
            [normalBtn, throwBtn, dashBtn].forEach(btn => {
                btn.style.backgroundColor = '';
                btn.className = 'flex-1 py-2 text-xs font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white';
            });
            
            // 设置选中按钮样式
            const selectedBtn = currentMoveType === 'normal' ? normalBtn : 
                               currentMoveType === 'throw' ? throwBtn : dashBtn;
            selectedBtn.style.backgroundColor = 'var(--theme-btn-primary)';
            selectedBtn.className = 'flex-1 py-2 text-xs font-bold transition-all text-white';
            
            // 显示/隐藏字段
            if (currentMoveType === 'dash') {
                frameFields.classList.add('hidden');
                dashFields.classList.remove('hidden');
            } else {
                frameFields.classList.remove('hidden');
                dashFields.classList.add('hidden');
                
                // 投技隐藏 Hit/Block 和 Knockdown 选项
                if (currentMoveType === 'throw') {
                    hitBlockFields.classList.add('hidden');
                    knockdownField.classList.add('hidden');
                } else {
                    hitBlockFields.classList.remove('hidden');
                    knockdownField.classList.remove('hidden');
                }
            }
        }
        
        function saveNewMove() {
            const name = document.getElementById('inputMoveName').value.trim().toUpperCase();
            
            if (!name) {
                alert('请输入招式名称');
                return;
            }
            
            // 检查是否重复
            const exists = state.moveLibrary.some(m => m.name.toUpperCase() === name);
            if (exists) {
                alert('该招式已存在');
                return;
            }
            
            let newMove;
            
            if (currentMoveType === 'dash') {
                const dashFrames = parseInt(document.getElementById('inputMoveDashFrames').value);
                if (!dashFrames || dashFrames <= 0) {
                    alert('请输入有效的 Dash 帧数');
                    return;
                }
                newMove = {
                    name,
                    isDash: true,
                    dashFrames,
                    isUserAdded: true  // 标记为用户添加
                };
            } else {
                const startup = parseInt(document.getElementById('inputMoveStartup').value);
                const active = document.getElementById('inputMoveActive').value.trim();
                const recovery = parseInt(document.getElementById('inputMoveRecovery').value);
                
                if (!startup || startup <= 0) {
                    alert('请输入有效的 Startup');
                    return;
                }
                if (!active) {
                    alert('请输入 Active 帧（如: 7-9 或 5-7,12-14）');
                    return;
                }
                if (!recovery || recovery < 0) {
                    alert('请输入有效的 Recovery');
                    return;
                }
                
                // 验证 active 格式
                const activeRegex = /^\d+(-\d+)?(,\d+(-\d+)?)*$/;
                if (!activeRegex.test(active)) {
                    alert('Active 格式不正确，请使用如 7-9 或 5-7,12-14 的格式');
                    return;
                }
                
                if (currentMoveType === 'throw') {
                    newMove = {
                        name,
                        startup,
                        active,
                        recovery,
                        isThrow: true,
                        isKnockdown: true,
                        isUserAdded: true
                    };
                } else {
                    const hit = parseInt(document.getElementById('inputMoveHit').value) || 0;
                    const block = parseInt(document.getElementById('inputMoveBlock').value) || 0;
                    const isKnockdown = document.getElementById('inputMoveKnockdown').checked;
                    
                    newMove = {
                        name,
                        startup,
                        active,
                        recovery,
                        hit,
                        block,
                        isKnockdown,
                        isUserAdded: true
                    };
                }
            }
            
            // 添加到招式库
            state.moveLibrary.push(newMove);
            
            // 更新缓存
            if (state.characterCache[state.currentCharacter]) {
                state.characterCache[state.currentCharacter].moves = [...state.moveLibrary];
            }
            
            // 保存到 localStorage
            saveMoves(state.currentCharacter, state.moveLibrary);
            
            closeAddMoveModal();
            renderAll();
            showToast(`已添加 ${name}`);
        }
        
        function renderRules() {
            const container = document.getElementById('rulesContainer');
            if (!container) return;
            
            const allRules = getAllRulesForCharacter(state.currentCharacter);
            
            if (allRules.length === 0) {
                container.innerHTML = '<div class="text-zinc-600 italic">暂无规则</div>';
                return;
            }
            
            container.innerHTML = allRules.map(rule => {
                const isGlobal = rule.isGlobal;
                const isPreset = rule.isPreset;
                const tagClass = isGlobal ? 'bg-zinc-700 text-zinc-400' : 'bg-cyan-900/50 text-cyan-400';
                const tagText = isGlobal ? '全局' : state.currentCharacter;
                // 只有全局规则不能删除，角色预设和自定义规则都可以删除
                const deleteBtn = isGlobal ? '' : `<button onclick="removeRule('${rule.id}')" class="text-zinc-600 hover:text-red-500 transition-colors p-2 -m-1 text-base" title="删除规则">✕</button>`;
                
                // 根据规则类型渲染不同的内容
                let content = '';
                let typeLabel = '';
                let typeColor = '';
                
                if (rule.type === 'disable') {
                    // 禁用压制规则
                    const usageLabels = {
                        'kill': '卡帧',
                        'meaty_after_kill': '卡帧后压制',
                        'meaty_direct': '直接压制'
                    };
                    typeLabel = '禁用';
                    typeColor = 'text-red-400';
                    content = `
                        <span class="${typeColor} font-bold">${escapeHtml(rule.moveName)}</span>
                        <span class="text-zinc-600 mx-1">→</span>
                        <span class="text-zinc-400">禁止${usageLabels[rule.usage] || rule.usage}</span>
                    `;
                } else if (rule.type === 'combo') {
                    // 禁用组合规则
                    typeLabel = '禁用';
                    typeColor = 'text-red-400';
                    content = `
                        <span class="${typeColor} font-mono">${escapeHtml(rule.move1)}</span>
                        <span class="text-zinc-600 mx-1">×</span>
                        <span class="${typeColor} font-mono">${escapeHtml(rule.move2)}</span>
                    `;
                } else if (rule.type === 'prefer') {
                    // 倾向压制规则
                    typeLabel = '倾向';
                    typeColor = 'text-green-400';
                    content = `
                        <span class="${typeColor} font-bold">${escapeHtml(rule.moveName)}</span>
                        <span class="text-zinc-400 ml-2">优先推荐为压制招式</span>
                    `;
                } else {
                    // 旧的 pattern 规则（兼容）
                    typeLabel = '禁用';
                    typeColor = 'text-red-400';
                    content = `
                        <span class="text-zinc-300 font-mono">${escapeHtml(rule.pattern1)}</span>
                        <span class="text-zinc-600 mx-1">×</span>
                        <span class="text-zinc-300 font-mono">${escapeHtml(rule.pattern2)}</span>
                    `;
                }
                
                return `
                    <div class="flex items-center justify-between py-1.5 px-2 bg-zinc-800/30 border-l-2 ${isGlobal ? 'border-zinc-600' : 'border-cyan-600'}">
                        <div class="flex items-center gap-2 flex-wrap">
                            <span class="text-[9px] px-1.5 py-0.5 ${tagClass} uppercase tracking-wide">${tagText}</span>
                            <span class="text-[9px] px-1.5 py-0.5 bg-zinc-700/50 ${typeColor} uppercase">${typeLabel}</span>
                            ${content}
                            ${rule.description ? `<span class="text-zinc-500 text-xs ml-2">— ${escapeHtml(rule.description)}</span>` : ''}
                        </div>
                        ${deleteBtn}
                    </div>
                `;
            }).join('');
        }
        
        // ==================== 模糊帧数功能 ====================
        // 模糊模式开关状态
        let fuzzyMode = false;
        // 模糊模式计算结果
        let fuzzyPreviewResult = null;
        
        // 切换模糊模式
        function toggleFuzzyMode() {
            fuzzyMode = !fuzzyMode;
            const switchEl = document.getElementById('fuzzySwitch');
            const labelExact = document.getElementById('fuzzyLabelExact');
            const labelFuzzy = document.getElementById('fuzzyLabelFuzzy');
            const exactGroup = document.getElementById('exactInputGroup');
            const fuzzyGroup = document.getElementById('fuzzyInputGroup');
            const hint = document.getElementById('advHint');
            const expectDetails = document.getElementById('expectDetails');
            
            if (fuzzyMode) {
                switchEl.classList.add('active');
                labelExact.classList.add('fuzzy-switch-label-inactive');
                labelFuzzy.classList.remove('fuzzy-switch-label-inactive');
                exactGroup.classList.add('hidden');
                fuzzyGroup.classList.remove('hidden');
                hint.textContent = '输入帧数范围，系统将计算覆盖所有情况的最优方案';
                // 隐藏期望后续（模糊模式不支持）
                expectDetails.classList.add('hidden');
                // 初始化计算
                calculateFuzzyPreview();
            } else {
                switchEl.classList.remove('active');
                labelExact.classList.remove('fuzzy-switch-label-inactive');
                labelFuzzy.classList.add('fuzzy-switch-label-inactive');
                exactGroup.classList.remove('hidden');
                fuzzyGroup.classList.add('hidden');
                hint.textContent = '范围 1~99';
                // 显示期望后续
                expectDetails.classList.remove('hidden');
                // 移除模糊预览
                removeFuzzyPreview();
            }
        }
        
        // 清理模糊输入
        function sanitizeFuzzyInput(inputId) {
            const input = document.getElementById(inputId);
            let val = input.value.replace(/[^0-9]/g, '');
            if (val.length > 2) val = val.slice(0, 2);
            if (parseInt(val) > 99) val = '99';
            if (val.length > 1 && val.startsWith('0')) val = val.replace(/^0+/, '');
            input.value = val;
        }
        
        // 移除模糊预览
        function removeFuzzyPreview() {
            const existing = document.getElementById('fuzzyPreviewContainer');
            if (existing) existing.remove();
            fuzzyPreviewResult = null;
        }
        
        // 计算模糊帧数预览
        function calculateFuzzyPreview() {
            const minAdv = parseInt(document.getElementById('inputAdvMin').value);
            const maxAdv = parseInt(document.getElementById('inputAdvMax').value);
            
            removeFuzzyPreview();
            
            if (!minAdv || !maxAdv || minAdv < 1 || maxAdv < 1 || minAdv > maxAdv) {
                return;
            }
            
            // 限制范围大小（避免计算量过大）
            if (maxAdv - minAdv > 10) {
                showFuzzyPreviewError('范围过大，请限制在10帧以内');
                return;
            }
            
            const result = calculateFuzzyBestPlans(minAdv, maxAdv);
            fuzzyPreviewResult = result;
            
            if (!result.bestByBlock && !result.bestByHit) {
                showFuzzyPreviewError('没有符合条件的方案<br><span class="text-xs text-zinc-500">约束: ①不被4帧抢(发生-偷帧≥4) ②不挥空</span>');
                return;
            }
            
            showFuzzyPreviewResult(result, minAdv, maxAdv);
        }
        
        // 显示模糊预览错误
        function showFuzzyPreviewError(message) {
            const container = document.createElement('div');
            container.id = 'fuzzyPreviewContainer';
            container.className = 'fuzzy-preview';
            container.innerHTML = `
                <div class="text-red-400 font-bold text-sm">❌ ${message}</div>
            `;
            document.getElementById('fuzzyInputGroup').after(container);
        }
        
        // 显示模糊预览结果
        function showFuzzyPreviewResult(result, minAdv, maxAdv) {
            const container = document.createElement('div');
            container.id = 'fuzzyPreviewContainer';
            container.className = 'fuzzy-preview';
            
            const allValidPlans = result.allPlans || [];
            let html = `<div class="fuzzy-preview-title">推荐方案 (${minAdv}~${maxAdv}F) - 共${allValidPlans.length}个</div>`;
            
            if (allValidPlans.length <= 2) {
                // ≤2 个方案，显示全部
                allValidPlans.forEach((plan, i) => {
                    html += renderFuzzyPreviewItem(plan, i === 0 ? '推荐' : '备选');
                });
            } else {
                // >2 个方案，显示最优两个
                if (result.bestByBlock) {
                    html += renderFuzzyPreviewItem(result.bestByBlock, '🛡️ 防御最优');
                }
                if (result.bestByHit && result.bestByHit.key !== result.bestByBlock?.key) {
                    html += renderFuzzyPreviewItem(result.bestByHit, '⚔️ 命中最优');
                }
            }
            
            container.innerHTML = html;
            document.getElementById('fuzzyInputGroup').after(container);
        }
        
        // 渲染单个模糊预览项
        function renderFuzzyPreviewItem(plan, label) {
            const safetyMargin = plan.startup - plan.maxStolen;
            return `
                <div class="fuzzy-preview-item">
                    <div class="fuzzy-preview-label">${label}</div>
                    <div class="fuzzy-preview-plan">${formatFuzzyPlan(plan)}</div>
                    <div class="fuzzy-preview-avg">
                        平均 Block: <span class="${getFrameColorClass(plan.avgBlock)}">${plan.avgBlock >= 0 ? '+' : ''}${plan.avgBlock.toFixed(1)}F</span>
                        | Hit: <span class="${getFrameColorClass(plan.avgHit)}">${plan.avgHit >= 0 ? '+' : ''}${plan.avgHit.toFixed(1)}F</span>
                    </div>
                    <div class="fuzzy-preview-detail">
                        偷帧: ${plan.minStolen}~${plan.maxStolen}F | 
                        安全余量: <span class="${safetyMargin >= 4 ? 'text-green-400' : 'text-red-400'}">${safetyMargin}F</span> (发生${plan.startup}-偷${plan.maxStolen})
                    </div>
                </div>
            `;
        }
        
        // 格式化模糊方案显示
        function formatFuzzyPlan(plan) {
            let result = '';
            if (plan.killDesc) {
                result += `<span class="text-zinc-400">${plan.killDesc} →</span> `;
            }
            result += plan.meatyMove.name;
            return result;
        }
        
        // ==================== 模糊帧数核心计算 ====================
        // 计算模糊帧数的最优方案
        // 约束1: 不被抢 - startup - stolen >= 4（对方最速4帧拳脚抢不到）
        // 约束2: 不挥空 - 招式active结束前对方一定起身
        function calculateFuzzyBestPlans(minAdv, maxAdv) {
            const allPlans = [];
            const rules = getAllRulesForCharacter(state.currentCharacter);
            
            // 获取可用的压制招式（有 active 且不是 dash/throw）
            const meatyMoves = state.moveLibrary.filter(m => 
                m.active && !m.isDash && !m.isThrow && !isMoveDisabled(m, 'meaty', rules)
            );
            
            // 获取所有卡帧方案（包括不卡帧、单步卡帧、双步卡帧）
            const killPlans = generateAllKillPlans(rules);
            
            for (const meatyMove of meatyMoves) {
                const ranges = parseActiveRanges(meatyMove.active);
                const startup = ranges[0].start;  // 招式发生帧
                const lastActiveEnd = ranges[ranges.length - 1].end;  // active 最后一帧
                
                for (const killPlan of killPlans) {
                    const killTotal = killPlan.total;
                    
                    // 计算剩余帧范围
                    const minRemain = minAdv - killTotal;
                    const maxRemain = maxAdv - killTotal;
                    
                    // 基础检查：剩余帧必须大于0
                    if (minRemain <= 0) continue;
                    
                    // 约束3: 能命中 - 对方最早起身时 active 已开始
                    // minRemain + 1 >= startup → minRemain >= startup - 1
                    if (minRemain < startup - 1) continue;
                    
                    // 约束2: 不挥空 - 对方最晚起身时 active 还没结束
                    // maxRemain + 1 <= lastActiveEnd → maxRemain <= lastActiveEnd - 1
                    if (maxRemain > lastActiveEnd - 1) continue;
                    
                    // 约束1: 不被抢 - 对方起身最晚时 startup - stolen >= 4
                    // maxStolen = maxRemain + 1 - startup
                    // startup - maxStolen >= 4
                    // startup - (maxRemain + 1 - startup) >= 4
                    // 2 * startup - maxRemain - 1 >= 4
                    // maxRemain <= 2 * startup - 5
                    if (maxRemain > 2 * startup - 5) continue;
                    
                    // 所有约束通过，计算平均帧数
                    let totalHit = 0, totalBlock = 0;
                    
                    for (let remain = minRemain; remain <= maxRemain; remain++) {
                        const targetFrame = remain + 1;
                        const hitInfo = checkActiveHit(meatyMove.active, targetFrame);
                        
                        if (hitInfo) {
                            totalHit += (meatyMove.hit || 0) + hitInfo.stolen;
                            totalBlock += (meatyMove.block || 0) + hitInfo.stolen;
                        }
                    }
                    
                    const count = maxRemain - minRemain + 1;
                    const key = `${killPlan.desc}|${meatyMove.name}`;
                    
                    // 计算范围内的偷帧情况（用于显示）
                    const minStolen = minRemain + 1 - startup;
                    const maxStolen = maxRemain + 1 - startup;
                    
                    allPlans.push({
                        key,
                        killPlan,
                        killDesc: killPlan.desc,
                        meatyMove,
                        avgHit: totalHit / count,
                        avgBlock: totalBlock / count,
                        minRemain,
                        maxRemain,
                        minStolen,
                        maxStolen,
                        startup
                    });
                }
            }
            
            if (allPlans.length === 0) {
                return { bestByBlock: null, bestByHit: null };
            }
            
            // 按平均 Block 降序排序
            const sortedByBlock = [...allPlans].sort((a, b) => b.avgBlock - a.avgBlock);
            // 按平均 Hit 降序排序
            const sortedByHit = [...allPlans].sort((a, b) => b.avgHit - a.avgHit);
            
            return {
                bestByBlock: sortedByBlock[0],
                bestByHit: sortedByHit[0],
                allPlans
            };
        }
        
        // 生成所有可能的卡帧方案
        function generateAllKillPlans(rules) {
            const plans = [];
            
            // 不卡帧（直接压制）
            plans.push({ total: 0, desc: '', moves: [] });
            
            // 单步卡帧
            for (const killMove of state.moveLibrary) {
                if (isMoveDisabled(killMove, 'kill', rules)) continue;
                
                let killTotal;
                if (killMove.isDash) {
                    killTotal = killMove.dashFrames || 19;
                } else if (killMove.active) {
                    const lastActive = getLastActiveFrame(killMove.active);
                    killTotal = lastActive + killMove.recovery;
                } else {
                    continue;
                }
                
                plans.push({ 
                    total: killTotal, 
                    desc: killMove.name, 
                    moves: [killMove] 
                });
            }
            
            // 双步卡帧
            for (const killMove1 of state.moveLibrary) {
                if (isMoveDisabled(killMove1, 'kill', rules)) continue;
                
                let killTotal1;
                if (killMove1.isDash) {
                    killTotal1 = killMove1.dashFrames || 19;
                } else if (killMove1.active) {
                    killTotal1 = getLastActiveFrame(killMove1.active) + killMove1.recovery;
                } else {
                    continue;
                }
                
                for (const killMove2 of state.moveLibrary) {
                    if (isMoveDisabled(killMove2, 'kill', rules)) continue;
                    if (isComboForbidden(killMove1, killMove2, rules)) continue;
                    
                    let killTotal2;
                    if (killMove2.isDash) {
                        killTotal2 = killMove2.dashFrames || 19;
                    } else if (killMove2.active) {
                        killTotal2 = getLastActiveFrame(killMove2.active) + killMove2.recovery;
                    } else {
                        continue;
                    }
                    
                    const total = killTotal1 + killTotal2;
                    // 避免重复（A+B 和 B+A 只保留一个）
                    const names = [killMove1.name, killMove2.name].sort();
                    const desc = `${names[0]} + ${names[1]}`;
                    
                    // 检查是否已存在相同方案
                    if (!plans.some(p => p.desc === desc)) {
                        plans.push({
                            total,
                            desc,
                            moves: [killMove1, killMove2]
                        });
                    }
                }
            }
            
            return plans;
        }
        
        // ==================== 期望后续功能 ====================
        // 当前期望模式：'remain' 或 'move'
        let expectMode = 'remain';
        // 当前计算出的期望方案
        let currentExpectPlan = null;
        
        function setExpectMode(mode) {
            expectMode = mode;
            
            // 更新按钮样式
            const remainBtn = document.getElementById('expectModeRemain');
            const moveBtn = document.getElementById('expectModeMove');
            const remainPanel = document.getElementById('expectRemainPanel');
            const movePanel = document.getElementById('expectMovePanel');
            
            if (mode === 'remain') {
                remainBtn.className = 'flex-1 py-3 text-sm font-bold transition-all modal-btn-active text-white';
                moveBtn.className = 'flex-1 py-3 text-sm font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white';
                remainPanel.classList.remove('hidden');
                movePanel.classList.add('hidden');
            } else {
                remainBtn.className = 'flex-1 py-3 text-sm font-bold transition-all bg-zinc-800 text-zinc-400 hover:text-white';
                moveBtn.className = 'flex-1 py-3 text-sm font-bold transition-all modal-btn-active text-white';
                remainPanel.classList.add('hidden');
                movePanel.classList.remove('hidden');
            }
            
            // 清除之前的结果
            currentExpectPlan = null;
            document.getElementById('expectResult').classList.add('hidden');
            
            // 重新计算
            calculateExpectPlan();
        }
        
        // 调整有利帧数值（+/- 按钮）
        function adjustAdv(delta) {
            const input = document.getElementById('inputAdv');
            let currentVal = parseInt(input.value);
            
            // 如果输入框为空，从 placeholder 值开始
            if (isNaN(currentVal) || input.value === '') {
                currentVal = 40; // placeholder 默认值
            }
            
            const newVal = currentVal + delta;
            
            // 范围限制：1~99
            if (newVal < 1 || newVal > 99) {
                return; // 超出范围，不执行
            }
            
            input.value = newVal;
            updateExpectOptions();
        }
        
        // 清理输入，只允许数字且范围 1~99
        function sanitizeAdvInput() {
            const input = document.getElementById('inputAdv');
            // 移除非数字字符
            let val = input.value.replace(/[^0-9]/g, '');
            
            // 限制最大两位数
            if (val.length > 2) {
                val = val.slice(0, 2);
            }
            
            // 如果输入的数字超过99，截断为99
            if (parseInt(val) > 99) {
                val = '99';
            }
            
            // 移除前导零（但保留单独的 0 以便继续输入）
            if (val.length > 1 && val.startsWith('0')) {
                val = val.replace(/^0+/, '');
            }
            
            input.value = val;
        }
        
        // 更新期望选项（当有利帧变化时）
        function updateExpectOptions() {
            // 更新招式下拉框选项
            const select = document.getElementById('inputExpectMove');
            
            // 保存当前选中的值
            const previousValue = select.value;
            
            select.innerHTML = '<option value="">-- 选择招式 --</option>';
            
            // 只显示有 active 且不是 dash/throw 的招式
            const availableMoves = state.moveLibrary.filter(m => m.active && !m.isDash && !m.isThrow);
            availableMoves.forEach(m => {
                const opt = document.createElement('option');
                opt.value = m.name;
                opt.textContent = `${m.name} (发生 ${m.startup}F, 持续 ${m.active}F)`;
                select.appendChild(opt);
            });
            
            // 恢复之前选中的值（如果该选项仍然存在）
            if (previousValue && availableMoves.some(m => m.name === previousValue)) {
                select.value = previousValue;
            }
            
            // 重新计算期望方案
            calculateExpectPlan();
        }
        
        // 计算期望方案
        function calculateExpectPlan() {
            const adv = parseInt(document.getElementById('inputAdv').value);
            const resultDiv = document.getElementById('expectResult');
            const resultContent = document.getElementById('expectResultContent');
            
            if (!adv || adv <= 0) {
                resultDiv.classList.add('hidden');
                currentExpectPlan = null;
                return;
            }
            
            let plan = null;
            
            if (expectMode === 'remain') {
                const targetRemain = parseInt(document.getElementById('inputExpectRemain').value);
                if (!targetRemain || targetRemain <= 0 || targetRemain >= adv) {
                    resultDiv.classList.add('hidden');
                    currentExpectPlan = null;
                    return;
                }
                plan = findFrameKillPlan(adv, targetRemain);
            } else {
                const moveName = document.getElementById('inputExpectMove').value;
                if (!moveName) {
                    resultDiv.classList.add('hidden');
                    currentExpectPlan = null;
                    return;
                }
                const move = state.moveLibrary.find(m => m.name === moveName);
                if (!move) {
                    resultDiv.classList.add('hidden');
                    currentExpectPlan = null;
                    return;
                }
                plan = findMoveKillPlan(adv, move);
            }
            
            currentExpectPlan = plan;
            resultDiv.classList.remove('hidden');
            
            if (plan) {
                resultContent.innerHTML = renderExpectPlanPreview(plan);
            } else {
                resultContent.innerHTML = `<div class="text-red-400 font-bold">❌ 没有对应卡帧解决方案</div>
                    <div class="text-zinc-500 text-xs mt-1">无论一步还是两步卡帧都无法达成此目标</div>`;
            }
        }
        
        // 查找能卡帧到指定剩余帧数的方案
        function findFrameKillPlan(adv, targetRemain) {
            const neededKill = adv - targetRemain;
            if (neededKill <= 0) return null;
            
            const rules = getAllRulesForCharacter(state.currentCharacter);
            
            // 方案A：一步卡帧
            for (const killMove of state.moveLibrary) {
                // 检查是否被禁用用于卡帧
                if (isMoveDisabled(killMove, 'kill', rules)) continue;
                
                let killTotal;
                if (killMove.isDash) {
                    killTotal = killMove.dashFrames || 19;
                } else if (killMove.active) {
                    const lastActive = getLastActiveFrame(killMove.active);
                    killTotal = lastActive + killMove.recovery;
                } else {
                    continue;
                }
                
                if (killTotal === neededKill) {
                    return {
                        type: 'single',
                        killMove,
                        killTotal,
                        remain: targetRemain,
                        displayMeaty: `+${targetRemain}F`
                    };
                }
            }
            
            // 方案C：两步卡帧
            for (const killMove1 of state.moveLibrary) {
                // 检查第一步是否被禁用用于卡帧
                if (isMoveDisabled(killMove1, 'kill', rules)) continue;
                
                let killTotal1;
                if (killMove1.isDash) {
                    killTotal1 = killMove1.dashFrames || 19;
                } else if (killMove1.active) {
                    const lastActive1 = getLastActiveFrame(killMove1.active);
                    killTotal1 = lastActive1 + killMove1.recovery;
                } else {
                    continue;
                }
                
                if (killTotal1 >= neededKill) continue;
                
                for (const killMove2 of state.moveLibrary) {
                    // 检查第二步是否被禁用用于卡帧
                    if (isMoveDisabled(killMove2, 'kill', rules)) continue;
                    
                    // 检查规则禁止组合
                    if (isComboForbidden(killMove1, killMove2, rules)) continue;
                    
                    let killTotal2;
                    if (killMove2.isDash) {
                        killTotal2 = killMove2.dashFrames || 19;
                    } else if (killMove2.active) {
                        const lastActive2 = getLastActiveFrame(killMove2.active);
                        killTotal2 = lastActive2 + killMove2.recovery;
                    } else {
                        continue;
                    }
                    
                    if (killTotal1 + killTotal2 === neededKill) {
                        return {
                            type: 'double',
                            killMove: killMove1,
                            killMove2,
                            killTotal: killTotal1,
                            killTotal2,
                            remain: targetRemain,
                            displayMeaty: `+${targetRemain}F`
                        };
                    }
                }
            }
            
            return null;
        }
        
        // 查找能用指定招式压制（偷至少1帧）的卡帧方案
        function findMoveKillPlan(adv, targetMove) {
            const rules = getAllRulesForCharacter(state.currentCharacter);
            const bestPlans = [];
            
            // 检查各种可能的剩余帧数，从大到小（偷帧越多越好）
            const ranges = parseActiveRanges(targetMove.active);
            const firstActiveStart = ranges[0].start;
            const lastActiveEnd = ranges[ranges.length - 1].end;
            
            // 计算可能的剩余帧范围：让 remain+1 落在 active 范围内
            // remain+1 >= firstActiveStart 且 remain+1 <= lastActiveEnd
            // 即 remain >= firstActiveStart - 1 且 remain <= lastActiveEnd - 1
            // 但我们要偷至少1帧，即 remain+1 > firstActiveStart，即 remain >= firstActiveStart
            for (let remain = firstActiveStart; remain <= lastActiveEnd - 1; remain++) {
                const targetFrame = remain + 1;
                const hitInfo = checkActiveHit(targetMove.active, targetFrame);
                
                if (hitInfo && hitInfo.stolen >= 1) {
                    const neededKill = adv - remain;
                    
                    // 特殊情况：不需要卡帧，直接压制
                    if (neededKill === 0) {
                        // 检查是否被禁用于直接压制
                        if (!isMoveDisabled(targetMove, 'meaty_direct', rules)) {
                            bestPlans.push({
                                type: 'direct',
                                remain: remain,
                                meatyMove: targetMove,
                                stolen: hitInfo.stolen,
                                finalHit: (targetMove.hit || 0) + hitInfo.stolen,
                                finalBlock: (targetMove.block || 0) + hitInfo.stolen,
                                displayMeaty: targetMove.name
                            });
                        }
                        continue;
                    }
                    
                    // 尝试找到卡帧方案
                    const plan = findFrameKillPlan(adv, remain);
                    if (plan) {
                        // 检查targetMove是否被禁用于卡帧后压制
                        if (!isMoveDisabled(targetMove, 'meaty_after_kill', rules)) {
                            bestPlans.push({
                                ...plan,
                                meatyMove: targetMove,
                                stolen: hitInfo.stolen,
                                finalHit: (targetMove.hit || 0) + hitInfo.stolen,
                                finalBlock: (targetMove.block || 0) + hitInfo.stolen,
                                displayMeaty: targetMove.name
                            });
                        }
                    }
                }
            }
            
            // 按偷帧数降序排序，返回最优方案
            if (bestPlans.length === 0) return null;
            bestPlans.sort((a, b) => b.stolen - a.stolen);
            return bestPlans[0];
        }
        
        // 渲染期望方案预览
        function renderExpectPlanPreview(plan) {
            let stepsHtml = '';
            
            if (plan.type === 'direct') {
                stepsHtml = `<div class="text-center">
                    <span class="text-zinc-500">直接</span>
                    <span class="text-cyan-400 font-black text-xl ml-2">${plan.displayMeaty}</span>
                </div>`;
            } else if (plan.type === 'single') {
                stepsHtml = `<div class="flex items-center justify-center gap-2">
                    <span class="text-white font-bold">${plan.killMove.name}</span>
                    <span class="text-zinc-600">(-${plan.killTotal}F)</span>
                    <span class="text-zinc-500">→</span>
                    <span class="text-cyan-400 font-black text-xl">${plan.displayMeaty}</span>
                </div>`;
            } else if (plan.type === 'double') {
                const remain1 = plan.killTotal;  // 第一步后的剩余
                stepsHtml = `<div class="flex items-center justify-center gap-2 flex-wrap">
                    <span class="text-white font-bold">${plan.killMove.name}</span>
                    <span class="text-zinc-600">(-${plan.killTotal}F)</span>
                    <span class="text-zinc-500">→</span>
                    <span class="text-white font-bold">${plan.killMove2.name}</span>
                    <span class="text-zinc-600">(-${plan.killTotal2}F)</span>
                    <span class="text-zinc-500">→</span>
                    <span class="text-cyan-400 font-black text-xl">${plan.displayMeaty}</span>
                </div>`;
            }
            
            // 如果有招式信息，显示帧数优势
            let statsHtml = '';
            if (plan.meatyMove) {
                const stolenColorPreview = getStolenColorClass(plan.stolen);
                const hitColorPreview = getFrameColorClass(plan.finalHit);
                const blockColorPreview = getFrameColorClass(plan.finalBlock);
                statsHtml = `<div class="mt-2 pt-2 border-t border-zinc-700 text-center text-xs">
                    <span class="text-zinc-500">偷</span><span class="${stolenColorPreview} font-bold ml-1">${plan.stolen}F</span>
                    <span class="text-zinc-500 ml-3">H</span><span class="${hitColorPreview} font-bold ml-1">${plan.finalHit >= 0 ? '+' : ''}${plan.finalHit}</span>
                    <span class="text-zinc-500 ml-3">B</span><span class="${blockColorPreview} font-bold ml-1">${plan.finalBlock >= 0 ? '+' : ''}${plan.finalBlock}</span>
                </div>`;
            }
            
            return `<div class="text-green-400 font-bold mb-2">✓ 找到可行方案</div>${stepsHtml}${statsHtml}`;
        }
        
        function openNoteModal() { 
            // 重置期望后续状态
            expectMode = 'remain';
            currentExpectPlan = null;
            document.getElementById('expectDetails').removeAttribute('open');
            document.getElementById('inputExpectRemain').value = '5';
            document.getElementById('inputExpectMove').value = '';
            document.getElementById('expectResult').classList.add('hidden');
            setExpectMode('remain');
            
            // 更新招式下拉框
            updateExpectOptions();
            
            document.getElementById('noteModal').classList.remove('hidden'); 
            document.getElementById('inputAdv').focus();
        }
        
        function closeModal() { 
            document.getElementById('noteModal').classList.add('hidden');
            // 清理状态
            currentExpectPlan = null;
            // 重置模糊模式
            if (fuzzyMode) {
                toggleFuzzyMode();
            }
            removeFuzzyPreview();
        }

        function switchTab(tab) {
            const viewNotes = document.getElementById('view-notes');
            const viewLibrary = document.getElementById('view-library');
            
            // 移除之前的动画类
            viewNotes.classList.remove('view-transition');
            viewLibrary.classList.remove('view-transition');
            
            viewNotes.classList.toggle('hidden', tab !== 'notes');
            viewLibrary.classList.toggle('hidden', tab !== 'library');
            document.getElementById('tab-notes').classList.toggle('active', tab === 'notes');
            document.getElementById('tab-library').classList.toggle('active', tab === 'library');
            
            // 添加入场动画
            requestAnimationFrame(() => {
                if (tab === 'notes') viewNotes.classList.add('view-transition');
                else viewLibrary.classList.add('view-transition');
            });
            
            // 更新滑动指示器位置
            updateTabIndicator(tab);
        }
        
        function updateTabIndicator(tab) {
            const indicator = document.getElementById('tabIndicator');
            const activeTab = document.getElementById(`tab-${tab}`);
            if (indicator && activeTab) {
                indicator.style.left = activeTab.offsetLeft + 'px';
                indicator.style.width = activeTab.offsetWidth + 'px';
            }
        }

        function saveNote() {
            const ctx = document.getElementById('inputContext').value.trim();
            
            // 模糊模式处理
            if (fuzzyMode) {
                const minAdv = parseInt(document.getElementById('inputAdvMin').value);
                const maxAdv = parseInt(document.getElementById('inputAdvMax').value);
                
                if (!minAdv || !maxAdv || minAdv < 1 || maxAdv < 1) {
                    alert('请输入有效的帧数范围 (1~99)');
                    return;
                }
                
                if (minAdv > maxAdv) {
                    alert('起始帧数不能大于结束帧数');
                    return;
                }
                
                if (maxAdv - minAdv > 10) {
                    alert('帧数范围不能超过10帧');
                    return;
                }
                
                if (!fuzzyPreviewResult || (!fuzzyPreviewResult.bestByBlock && !fuzzyPreviewResult.bestByHit)) {
                    alert('没有找到能覆盖整个范围的方案，请调整帧数范围');
                    return;
                }
                
                // 添加范围内的所有场景
                const contextPrefix = ctx || `模糊场景 ${minAdv}~${maxAdv}F`;
                for (let adv = minAdv; adv <= maxAdv; adv++) {
                    // 检查是否已存在相同帧数的场景
                    const exists = state.notes.some(n => n.adv === adv && n.context === contextPrefix);
                    if (!exists) {
                        state.notes.push({ 
                            adv, 
                            context: contextPrefix, 
                            isUserAdded: true,
                            isFuzzy: true,  // 标记为模糊场景
                            fuzzyRange: { min: minAdv, max: maxAdv }
                        });
                    }
                }
                
                saveScenarios(state.currentCharacter, state.notes);
                document.getElementById('inputAdvMin').value = '';
                document.getElementById('inputAdvMax').value = '';
                removeFuzzyPreview();
                closeModal();
                renderNotes();
                showToast(`已添加 ${minAdv}~${maxAdv}F 模糊场景`);
                return;
            }
            
            // 精确模式处理
            const adv = parseInt(document.getElementById('inputAdv').value);
            
            if (!adv || adv < 1 || adv > 99) {
                alert('请输入有效的有利帧数 (1~99)');
                return;
            }
            
            // 合理范围检查（超过70帧的有利很少见）
            if (adv > 70) {
                if (!confirm(`+${adv}F 是一个非常大的有利帧数，确定要添加吗？`)) {
                    return;
                }
            }
            
            // 检查是否启用了期望后续功能
            const expectDetailsOpen = document.getElementById('expectDetails').hasAttribute('open');
            if (expectDetailsOpen) {
                // 检查用户是否输入了期望
                let hasExpectInput = false;
                if (expectMode === 'remain') {
                    hasExpectInput = !!document.getElementById('inputExpectRemain').value;
                } else {
                    hasExpectInput = !!document.getElementById('inputExpectMove').value;
                }
                
                // 如果用户输入了期望但没有可行方案，阻止添加
                if (hasExpectInput && !currentExpectPlan) {
                    alert('期望后续没有可行的卡帧方案，请修改期望或折叠期望后续选项后再添加');
                    return;
                }
            }
            
            state.notes.push({ adv, context: ctx || "自定义场景", isUserAdded: true });
            saveScenarios(state.currentCharacter, state.notes); // 只保存用户自定义的部分
            document.getElementById('inputAdv').value = '';
            document.getElementById('inputContext').value = '';
            closeModal();
            renderNotes();
            showToast(`已添加 +${adv}F 场景`);
        }

        function removeNote(idx) {
            const note = state.notes[idx];
            const isPreset = !note.isUserAdded;
            
            // 如果是预设场景，给出提示
            if (isPreset) {
                if (!confirm(`确定要删除预设场景 "${note.context}" 吗？\n\n此场景可通过"重置"按钮恢复。`)) {
                    return;
                }
            }
            
            state.notes.splice(idx, 1);
            saveScenarios(state.currentCharacter, state.notes); // 只保存用户自定义的部分
            renderNotes();
            
            const tipMsg = isPreset ? '已隐藏预设场景（可通过重置恢复）' : '已删除场景';
            showToast(tipMsg);
        }

        function resetToDefault() {
            const userCount = state.notes.filter(n => n.isUserAdded).length;
            const confirmMsg = userCount > 0 
                ? `重置 ${state.currentCharacter} 的 Scenarios 为预设值？\n（将清除 ${userCount} 个用户自定义场景，保留所有预设场景）`
                : `重置 ${state.currentCharacter} 的 Scenarios 为预设值？`;
            
            if (confirm(confirmMsg)) {
                state.notes = resetScenarios(state.currentCharacter);
                renderNotes();
                showToast('已重置为预设场景');
            }
        }
        
        function removeMove(idx) { 
            const move = state.moveLibrary[idx];
            if (!move) return;
            
            // 预设招式不能删除
            if (!move.isUserAdded) {
                showToast('预设招式不可删除');
                return;
            }
            
            // 用户添加的招式需要确认
                if (!confirm(`确定要删除招式 "${move.name}" 吗？`)) {
                    return;
            }
            
            const moveName = move.name;
            state.moveLibrary.splice(idx, 1);
            // 同步更新缓存
            if (state.characterCache[state.currentCharacter]) {
                state.characterCache[state.currentCharacter].moves = [...state.moveLibrary];
            }
            // 保存到 localStorage
            saveMoves(state.currentCharacter, state.moveLibrary);
            renderAll(); 
            showToast(`已删除 ${moveName}`);
        }

        function clearLibrary() {
            if (confirm(`确定清空 ${state.currentCharacter} 的所有帧数据？`)) {
                state.moveLibrary = [];
                if (state.characterCache[state.currentCharacter]) {
                    state.characterCache[state.currentCharacter].moves = [];
                }
                // 清除 localStorage 中的保存
                clearSavedMoves(state.currentCharacter);
                renderAll();
            }
        }
        
        function resetMovesToDefault() {
            if (confirm(`重置 ${state.currentCharacter} 的招式数据为预设值？`)) {
                state.moveLibrary = resetMoves(state.currentCharacter);
                if (state.characterCache[state.currentCharacter]) {
                    state.characterCache[state.currentCharacter].moves = [...state.moveLibrary];
                }
                renderAll();
            }
        }

        function loadTemplate() {
            const template = `[
  {"name": "5MP", "startup": 6, "active": "6-9", "recovery": 15, "hit": 5, "block": 0},
  {"name": "5LP", "startup": 4, "active": "4-6", "recovery": 7, "hit": 4, "block": -1}
]`;
            document.getElementById('rawPaste').value = template;
            document.getElementById('rawPaste').focus();
        }

        function importJson() {
            const input = document.getElementById('rawPaste').value.trim();
            if (!input) {
                alert('请先粘贴 JSON 数据');
                return;
            }
            
            try {
                const data = JSON.parse(input);
                const newMoves = Array.isArray(data) ? data : [data];
                
                // 验证数据格式
                for (const move of newMoves) {
                    if (!move.name || move.startup === undefined) {
                        throw new Error('数据格式错误：缺少 name 或 startup 字段');
                    }
                }
                
                state.moveLibrary = [...state.moveLibrary, ...newMoves];
                
                // 去重 (基于 name)
                const seen = new Set();
                state.moveLibrary = state.moveLibrary.filter(m => {
                    if (seen.has(m.name)) return false;
                    seen.add(m.name);
                    return true;
                });
                
                // 更新缓存
                if (state.characterCache[state.currentCharacter]) {
                    state.characterCache[state.currentCharacter].moves = [...state.moveLibrary];
                }
                
                // 保存到 localStorage
                saveMoves(state.currentCharacter, state.moveLibrary);
                
                document.getElementById('rawPaste').value = '';
                renderAll();
                showToast(`已导入 ${newMoves.length} 个招式`);
            } catch (e) {
                showToast('JSON 格式错误', 'error');
                console.error('JSON 解析错误:', e);
            }
        }

        // ==================== 键盘事件 ====================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
                closeCharModal();
                closeHelpModal();
                closeRuleModal();
                closeAddMoveModal();
            }
            // Enter 键保存
            if (e.key === 'Enter') {
                if (!document.getElementById('noteModal').classList.contains('hidden')) {
                    saveNote();
                } else if (!document.getElementById('ruleModal').classList.contains('hidden')) {
                    saveRule();
                } else if (!document.getElementById('addMoveModal').classList.contains('hidden')) {
                    saveNewMove();
                }
            }
        });

        // ==================== 初始化 ====================
        window.onload = function() {
            console.log('=== SF6 FRAME LAB 初始化 ===');
            
            // 设置禁用场景说明监听器
            const usageSelect = document.getElementById('inputDisableUsage');
            const hintDiv = document.getElementById('disableUsageHint');
            
            if (usageSelect && hintDiv) {
                usageSelect.addEventListener('change', () => {
                    const hints = {
                        'kill': '禁止此招式用于消耗有利帧',
                        'meaty_after_kill': '禁止此招式在卡帧后作为压制招式',
                        'meaty_direct': '禁止此招式直接压制（不卡帧）'
                    };
                    hintDiv.textContent = hints[usageSelect.value] || '';
                });
            }
            
            // 0. 从 localStorage 恢复上次选择的角色
            let savedCharacter = loadCurrentCharacter();
            // 确保保存的角色有数据，否则回退到JURI
            if (!CONFIG.CHARACTERS_WITH_DATA.includes(savedCharacter)) {
                savedCharacter = 'JURI';
            }
            state.currentCharacter = savedCharacter;
            document.getElementById('currentCharIcon').textContent = getCharIcon(savedCharacter);
            
            // 应用角色主题
            applyTheme(savedCharacter);
            console.log(`[角色] 恢复上次选择: ${savedCharacter}`);
            
            console.log(`CHARACTER_DATA 已加载角色:`, Object.keys(CHARACTER_DATA));
            
            // 1. 加载角色数据 (优先 localStorage，其次全局变量 CHARACTER_DATA)
            const loadSuccess = loadCharacterData(state.currentCharacter);
            console.log(`数据加载${loadSuccess ? '成功' : '失败'}`);
            
            // 2. 加载scenarios: 预设 + 用户自定义
            state.notes = loadAllScenarios(state.currentCharacter);
            console.log(`[Scenarios] 加载完成: 预设 ${getDefaultScenarios(state.currentCharacter).length} 个 + 用户自定义 ${loadScenariosFromStorage(state.currentCharacter).length} 个`);
            
            // 3. 加载角色专属规则
            state.characterRules[state.currentCharacter] = loadCharacterRules(state.currentCharacter);
            console.log(`[Rules] 加载 ${state.characterRules[state.currentCharacter].length} 个角色规则`);
            
            // 4. 加载已删除的预设规则
            state.deletedPresetRules = loadDeletedPresetRules();
            console.log(`[Rules] 加载 ${Object.keys(state.deletedPresetRules).length} 个已删除预设规则`);
            
            // 5. 加载收藏模板系统
            state.favoriteTemplates = loadFavoriteTemplates();
            state.templateModifyWarned = loadTemplateModifyWarned();
            
            // 5.1 兼容旧版收藏数据，自动迁移
            state.favorites = loadFavorites();
            state.mixupFavorites = loadMixupFavorites();
            if (Object.keys(state.favorites).length > 0 || Object.keys(state.mixupFavorites).length > 0) {
                if (Object.keys(state.favoriteTemplates).length === 0) {
                    migrateLegacyFavorites();
                    saveFavoriteTemplates();
                    console.log('[迁移] 旧版收藏数据已自动迁移到新系统');
                }
            }
            
            // 初始化当前角色的模板结构
            initCharacterTemplates(state.currentCharacter);
            console.log(`[模板] 加载 ${Object.keys(state.favoriteTemplates[state.currentCharacter]?.templates || {}).length} 个收藏模板`);
            
            // 5.2 加载最小化状态
            state.minimized = loadMinimized();
            console.log(`[UI] 加载 ${Object.keys(state.minimized).length} 个最小化`);
            
            // 6. 加载打投择隐藏状态
            state.mixupHidden = loadMixupHidden();
            console.log(`[Mixup] 加载 ${Object.keys(state.mixupHidden).length} 个隐藏`);
            
            console.log(`最终状态: ${state.moveLibrary.length} 招式, ${state.notes.length} 场景`);
            console.log('=== 初始化完成 ===');
            
            updateSortOrderUI();
            renderAll();
            
            // 初始化 Tab 指示器位置
            setTimeout(() => updateTabIndicator('notes'), 100);
            
            // 初始化封条滚动内容
            updateMarqueeTape();
            
            // 标记加载完成，启用页面过渡
            requestAnimationFrame(() => {
                document.documentElement.classList.add('loaded');
                // 首次加载时触发角色按钮动画（延迟一点让页面先渲染）
                setTimeout(() => {
                    triggerCharBtnAnimation();
                }, 300);
            });
            
            // 初始化 Lucide 图标
            lucide.createIcons();
        };
        
        // 初始化/更新封条滚动效果
        function updateMarqueeTape() {
            const charName = state.currentCharacter;
            const charIcon = getCharIcon(charName);
            
            // 封条内容：emoji + 角色名，交替显示
            // 增加重复次数确保内容足够长，避免滚动时出现空白
            const repeatCount = 20;
            const content = Array(repeatCount).fill(`<span>${charIcon} ${charName}</span>`).join('');
            
            document.getElementById('marqueeContent1').innerHTML = content;
            document.getElementById('marqueeContent1Clone').innerHTML = content;
            document.getElementById('marqueeContent2').innerHTML = content;
            document.getElementById('marqueeContent2Clone').innerHTML = content;
        }
        
        // ==================== SF6 导航菜单控制 ====================
        const sf6MenuBtn = document.getElementById('sf6MenuBtn');
        const sf6CloseMenu = document.getElementById('sf6CloseMenu');
        const sf6FullscreenMenu = document.getElementById('sf6FullscreenMenu');
        
        sf6MenuBtn.addEventListener('click', () => {
            sf6FullscreenMenu.classList.add('active');
        });
        
        sf6CloseMenu.addEventListener('click', closeSf6Menu);
        
        function closeSf6Menu() {
            sf6FullscreenMenu.classList.remove('active');
        }
        
        // ESC 键关闭菜单
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && sf6FullscreenMenu.classList.contains('active')) {
                closeSf6Menu();
            }
        });
    </script>
</body>
</html>
